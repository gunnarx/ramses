<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAMSES Documentation: ramses::RendererSceneControl Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ramses_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RAMSES Documentation
   &#160;<span id="projectnumber">25.0.1</span>
   </div>
   <div id="projectbrief">Information for RAMSES users and developers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceramses.html">ramses</a></li><li class="navelem"><a class="el" href="classramses_1_1RendererSceneControl.html">RendererSceneControl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classramses_1_1RendererSceneControl-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ramses::RendererSceneControl Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Control states of scenes.  
 <a href="classramses_1_1RendererSceneControl.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RendererSceneControl_8h_source.html">RendererSceneControl.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ramses::RendererSceneControl:</div>
<div class="dyncontent">
<div class="center"><img src="classramses_1_1RendererSceneControl__inherit__graph.png" border="0" usemap="#ramses_1_1RendererSceneControl_inherit__map" alt="Inheritance graph"/></div>
<map name="ramses_1_1RendererSceneControl_inherit__map" id="ramses_1_1RendererSceneControl_inherit__map">
<area shape="rect" id="node2" href="classramses_1_1StatusObject.html" title="The StatusObject provides status message handling. " alt="" coords="33,5,183,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ramses::RendererSceneControl:</div>
<div class="dyncontent">
<div class="center"><img src="classramses_1_1RendererSceneControl__coll__graph.png" border="0" usemap="#ramses_1_1RendererSceneControl_coll__map" alt="Collaboration graph"/></div>
<map name="ramses_1_1RendererSceneControl_coll__map" id="ramses_1_1RendererSceneControl_coll__map">
<area shape="rect" id="node2" href="classramses_1_1StatusObject.html" title="The StatusObject provides status message handling. " alt="" coords="33,5,183,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3a67e00fdc6770676e44f1bc254604a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControl.html#a3a67e00fdc6770676e44f1bc254604a0">setSceneState</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, <a class="el" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82c">RendererSceneState</a> state)</td></tr>
<tr class="memdesc:a3a67e00fdc6770676e44f1bc254604a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request state change of a scene.  <a href="#a3a67e00fdc6770676e44f1bc254604a0">More...</a><br /></td></tr>
<tr class="separator:a3a67e00fdc6770676e44f1bc254604a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4065e5ff1fad466e3524022a368711d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControl.html#a4065e5ff1fad466e3524022a368711d9">setSceneMapping</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, <a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> displayId)</td></tr>
<tr class="memdesc:a4065e5ff1fad466e3524022a368711d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set scene display mapping.  <a href="#a4065e5ff1fad466e3524022a368711d9">More...</a><br /></td></tr>
<tr class="separator:a4065e5ff1fad466e3524022a368711d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865b4e80546bf49191ec6307f0c39b17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControl.html#a865b4e80546bf49191ec6307f0c39b17">setSceneDisplayBufferAssignment</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, <a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> displayBuffer, int32_t sceneRenderOrder=0)</td></tr>
<tr class="memdesc:a865b4e80546bf49191ec6307f0c39b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set scene display buffer assignment.  <a href="#a865b4e80546bf49191ec6307f0c39b17">More...</a><br /></td></tr>
<tr class="separator:a865b4e80546bf49191ec6307f0c39b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404275629b0b73ad04d10f4a1649e8ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControl.html#a404275629b0b73ad04d10f4a1649e8ba">linkOffscreenBuffer</a> (<a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> offscreenBufferId, <a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> consumerSceneId, <a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a> consumerDataSlotId)</td></tr>
<tr class="memdesc:a404275629b0b73ad04d10f4a1649e8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links display's offscreen buffer to a data consumer in scene.  <a href="#a404275629b0b73ad04d10f4a1649e8ba">More...</a><br /></td></tr>
<tr class="separator:a404275629b0b73ad04d10f4a1649e8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a77700e389a32581ad1b274552b010"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControl.html#af4a77700e389a32581ad1b274552b010">linkData</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> providerSceneId, <a class="el" href="namespaceramses.html#ab41878ab3cb9b206b58f32437faddd7f">dataProviderId_t</a> providerId, <a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> consumerSceneId, <a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a> consumerId)</td></tr>
<tr class="memdesc:af4a77700e389a32581ad1b274552b010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links a data provider from one scene to a data consumer in another scene.  <a href="#af4a77700e389a32581ad1b274552b010">More...</a><br /></td></tr>
<tr class="separator:af4a77700e389a32581ad1b274552b010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3705492a690fa9ec03ce9f5a50e74994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControl.html#a3705492a690fa9ec03ce9f5a50e74994">unlinkData</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> consumerSceneId, <a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a> consumerId)</td></tr>
<tr class="memdesc:a3705492a690fa9ec03ce9f5a50e74994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an existing link between data provider and consumer (<a class="el" href="classramses_1_1RendererSceneControl.html#af4a77700e389a32581ad1b274552b010" title="Links a data provider from one scene to a data consumer in another scene. ">linkData</a>) or offscreen buffer and consumer (<a class="el" href="classramses_1_1RendererSceneControl.html#a404275629b0b73ad04d10f4a1649e8ba" title="Links display&#39;s offscreen buffer to a data consumer in scene. ">linkOffscreenBuffer</a>).  <a href="#a3705492a690fa9ec03ce9f5a50e74994">More...</a><br /></td></tr>
<tr class="separator:a3705492a690fa9ec03ce9f5a50e74994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6420e4d8b2754d6ac8831a3bda9233bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControl.html#a6420e4d8b2754d6ac8831a3bda9233bb">handlePickEvent</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, float bufferNormalizedCoordX, float bufferNormalizedCoordY)</td></tr>
<tr class="memdesc:a6420e4d8b2754d6ac8831a3bda9233bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger renderer to test if given pick event with coordinates intersects with any instances of <a class="el" href="classramses_1_1PickableObject.html" title="PickableObject provides a way to specify a &#39;pickable&#39; area. ">ramses::PickableObject</a> contained in given scene. If so, the intersected PickableObjects are reported to <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">ramses::RendererSceneControl</a> (see ramses::IRendererEventHandler::objectsPicked) using their user IDs given at creation time (see <a class="el" href="classramses_1_1Scene.html#a124cab244a81f0558d3c68ad339d3478" title="Create a PickableObject. ">ramses::Scene::createPickableObject</a>).  <a href="#a6420e4d8b2754d6ac8831a3bda9233bb">More...</a><br /></td></tr>
<tr class="separator:a6420e4d8b2754d6ac8831a3bda9233bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae8c8a433e1a29ea4912d1db4be7311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControl.html#afae8c8a433e1a29ea4912d1db4be7311">flush</a> ()</td></tr>
<tr class="memdesc:afae8c8a433e1a29ea4912d1db4be7311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits scene control commands (API calls on <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">RendererSceneControl</a>) since previous flush to be executed in the next renderer update loop. This mechanism allows for 'atomic' changes that are applied within a single update loop, thus a single rendered frame. For example one scene can be hidden, another scene shown and data linked, all within single frame. Not all state changes can be executed within a single update loop, see <a class="el" href="classramses_1_1RendererSceneControl.html#a3a67e00fdc6770676e44f1bc254604a0" title="Request state change of a scene. ">setSceneState</a> for details.  <a href="#afae8c8a433e1a29ea4912d1db4be7311">More...</a><br /></td></tr>
<tr class="separator:afae8c8a433e1a29ea4912d1db4be7311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bb4710634109f444c018149b54dd92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControl.html#a78bb4710634109f444c018149b54dd92">dispatchEvents</a> (<a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html">IRendererSceneControlEventHandler</a> &amp;eventHandler)</td></tr>
<tr class="memdesc:a78bb4710634109f444c018149b54dd92"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">RendererSceneControl</a> methods push commands to an internal queue which is submitted when calling <a class="el" href="classramses_1_1RendererSceneControl.html#afae8c8a433e1a29ea4912d1db4be7311" title="Submits scene control commands (API calls on RendererSceneControl) since previous flush to be execute...">flush</a>. The commands are then executed during a render loop (<a class="el" href="classramses_1_1RamsesRenderer.html#a8bceaf9ed2fd659a05d2b12645a6bfdd" title="Prepare content to be rendered in next frame and render next frame. This function can not be used in ...">ramses::RamsesRenderer::doOneLoop</a> or in a render thread if used <a class="el" href="classramses_1_1RamsesRenderer.html#a90489cf440602591c90f7a08bb5958ab" title="Runs the renderer loop in a separate thread created and owned by the renderer. This function can not ...">ramses::RamsesRenderer::startThread</a>). Some of these calls result in an event (can be both informational and data). Such events and their result can be retrieved using the dispatchEvents call. <a class="el" href="classramses_1_1Scene.html" title="The Scene holds a scene graph. It is the essential class for distributing content to the ramses syste...">Scene</a> control events should be regularly consumed by calling <a class="el" href="classramses_1_1RendererSceneControl.html#a78bb4710634109f444c018149b54dd92" title="RendererSceneControl methods push commands to an internal queue which is submitted when calling flush...">dispatchEvents</a> in order to prevent buffer overflow of the internal event queue, even if the application is not interested in those events.  <a href="#a78bb4710634109f444c018149b54dd92">More...</a><br /></td></tr>
<tr class="separator:a78bb4710634109f444c018149b54dd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47395ff51c80461e50a4fe3eb449d924"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControl.html#a47395ff51c80461e50a4fe3eb449d924">RendererSceneControl</a> ()=delete</td></tr>
<tr class="memdesc:a47395ff51c80461e50a4fe3eb449d924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted default constructor.  <a href="#a47395ff51c80461e50a4fe3eb449d924">More...</a><br /></td></tr>
<tr class="separator:a47395ff51c80461e50a4fe3eb449d924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4c8ef6e0a37d581d08bc7064304ae8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControl.html#a5e4c8ef6e0a37d581d08bc7064304ae8">RendererSceneControl</a> (const <a class="el" href="classramses_1_1RendererSceneControl.html">RendererSceneControl</a> &amp;)=delete</td></tr>
<tr class="memdesc:a5e4c8ef6e0a37d581d08bc7064304ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <a href="#a5e4c8ef6e0a37d581d08bc7064304ae8">More...</a><br /></td></tr>
<tr class="separator:a5e4c8ef6e0a37d581d08bc7064304ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9def7e1bd04213343d90553860ba4ae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classramses_1_1RendererSceneControl.html">RendererSceneControl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControl.html#a9def7e1bd04213343d90553860ba4ae9">operator=</a> (const <a class="el" href="classramses_1_1RendererSceneControl.html">RendererSceneControl</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a9def7e1bd04213343d90553860ba4ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment.  <a href="#a9def7e1bd04213343d90553860ba4ae9">More...</a><br /></td></tr>
<tr class="separator:a9def7e1bd04213343d90553860ba4ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classramses_1_1StatusObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classramses_1_1StatusObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classramses_1_1StatusObject.html">ramses::StatusObject</a></td></tr>
<tr class="memitem:a1f22f4fa83016eb344ccb8a20c1e7921 inherit pub_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a1f22f4fa83016eb344ccb8a20c1e7921">validate</a> () const</td></tr>
<tr class="memdesc:a1f22f4fa83016eb344ccb8a20c1e7921 inherit pub_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates verbose validation of the object. Checks validity of internal values, references, states and performance warnings. Result can be obtained by calling <code><a class="el" href="classramses_1_1StatusObject.html#a9c270ef1525b1836e40a57713cbab999" title="Provides verbose report in human readable form generated by validate(). ">getValidationReport()</a></code>.  <a href="classramses_1_1StatusObject.html#a1f22f4fa83016eb344ccb8a20c1e7921">More...</a><br /></td></tr>
<tr class="separator:a1f22f4fa83016eb344ccb8a20c1e7921 inherit pub_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c270ef1525b1836e40a57713cbab999 inherit pub_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a9c270ef1525b1836e40a57713cbab999">getValidationReport</a> (<a class="el" href="namespaceramses.html#a2fe664af611fc05c4c7a487e195cceab">EValidationSeverity</a> severity=<a class="el" href="namespaceramses.html#a2fe664af611fc05c4c7a487e195cceabad806be26d26e0564001532670b1ccb6f">EValidationSeverity_Info</a>) const</td></tr>
<tr class="memdesc:a9c270ef1525b1836e40a57713cbab999 inherit pub_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides verbose report in human readable form generated by <code><a class="el" href="classramses_1_1StatusObject.html#a1f22f4fa83016eb344ccb8a20c1e7921" title="Generates verbose validation of the object. Checks validity of internal values, references, states and performance warnings. Result can be obtained by calling getValidationReport(). ">validate()</a></code>.  <a href="classramses_1_1StatusObject.html#a9c270ef1525b1836e40a57713cbab999">More...</a><br /></td></tr>
<tr class="separator:a9c270ef1525b1836e40a57713cbab999 inherit pub_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbbfea27c8eb369b1f21de42f2e88b1 inherit pub_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1">getStatusMessage</a> (<a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> status) const</td></tr>
<tr class="memdesc:a1fbbfea27c8eb369b1f21de42f2e88b1 inherit pub_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string description for a status provided by a RAMSES API function.  <a href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1">More...</a><br /></td></tr>
<tr class="separator:a1fbbfea27c8eb369b1f21de42f2e88b1 inherit pub_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7d7495b7a081aa9bc3a4b8eac36e19 inherit pub_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a0e7d7495b7a081aa9bc3a4b8eac36e19">StatusObject</a> (const <a class="el" href="classramses_1_1StatusObject.html">StatusObject</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a0e7d7495b7a081aa9bc3a4b8eac36e19 inherit pub_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <a href="classramses_1_1StatusObject.html#a0e7d7495b7a081aa9bc3a4b8eac36e19">More...</a><br /></td></tr>
<tr class="separator:a0e7d7495b7a081aa9bc3a4b8eac36e19 inherit pub_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1d8fa3051147db0ecb18c1ce500ee2 inherit pub_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classramses_1_1StatusObject.html">StatusObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a2e1d8fa3051147db0ecb18c1ce500ee2">operator=</a> (const <a class="el" href="classramses_1_1StatusObject.html">StatusObject</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a2e1d8fa3051147db0ecb18c1ce500ee2 inherit pub_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment.  <a href="classramses_1_1StatusObject.html#a2e1d8fa3051147db0ecb18c1ce500ee2">More...</a><br /></td></tr>
<tr class="separator:a2e1d8fa3051147db0ecb18c1ce500ee2 inherit pub_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a60c4e15091952c047f530de2c6ba9c11"><td class="memItemLeft" align="right" valign="top">class RendererSceneControlImpl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControl.html#a60c4e15091952c047f530de2c6ba9c11">impl</a></td></tr>
<tr class="memdesc:a60c4e15091952c047f530de2c6ba9c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores internal data for implementation specifics.  <a href="#a60c4e15091952c047f530de2c6ba9c11">More...</a><br /></td></tr>
<tr class="separator:a60c4e15091952c047f530de2c6ba9c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classramses_1_1StatusObject"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classramses_1_1StatusObject')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classramses_1_1StatusObject.html">ramses::StatusObject</a></td></tr>
<tr class="memitem:a248c9883d91fdb952853f4e46f5daca6 inherit pub_attribs_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">class StatusObjectImpl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a248c9883d91fdb952853f4e46f5daca6">impl</a></td></tr>
<tr class="separator:a248c9883d91fdb952853f4e46f5daca6 inherit pub_attribs_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ace582ac764d79427772152785e51845b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControl.html#ace582ac764d79427772152785e51845b">RamsesRendererImpl</a></td></tr>
<tr class="memdesc:ace582ac764d79427772152785e51845b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classramses_1_1RendererSceneControl__legacy.html" title="Control states of scenes. ">RendererSceneControl_legacy</a> can only be instantiated through <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>.  <a href="#ace582ac764d79427772152785e51845b">More...</a><br /></td></tr>
<tr class="separator:ace582ac764d79427772152785e51845b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classramses_1_1StatusObject"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classramses_1_1StatusObject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classramses_1_1StatusObject.html">ramses::StatusObject</a></td></tr>
<tr class="memitem:a19aaed5d79ca0590e38e800734e65751 inherit pro_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a19aaed5d79ca0590e38e800734e65751">StatusObject</a> (StatusObjectImpl &amp;pimpl)</td></tr>
<tr class="memdesc:a19aaed5d79ca0590e38e800734e65751 inherit pro_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <a class="el" href="classramses_1_1StatusObject.html" title="The StatusObject provides status message handling. ">StatusObject</a>.  <a href="classramses_1_1StatusObject.html#a19aaed5d79ca0590e38e800734e65751">More...</a><br /></td></tr>
<tr class="separator:a19aaed5d79ca0590e38e800734e65751 inherit pro_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdea643fe5ab0db7ad2bf888928ff48a inherit pro_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#afdea643fe5ab0db7ad2bf888928ff48a">~StatusObject</a> ()</td></tr>
<tr class="memdesc:afdea643fe5ab0db7ad2bf888928ff48a inherit pro_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the <a class="el" href="classramses_1_1StatusObject.html" title="The StatusObject provides status message handling. ">StatusObject</a>.  <a href="classramses_1_1StatusObject.html#afdea643fe5ab0db7ad2bf888928ff48a">More...</a><br /></td></tr>
<tr class="separator:afdea643fe5ab0db7ad2bf888928ff48a inherit pro_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Control states of scenes. </p>
<p>Where <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">ramses::RamsesRenderer</a> is used to configure general rendering (create displays, control looping and other global rendering states), <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">RendererSceneControl</a> is used to configure which content should be rendered and where. Scenes can be assigned to display buffers, shown, hidden, data linked, etc. All the commands in this class are put to a queue and submitted only when <a class="el" href="classramses_1_1RendererSceneControl.html#afae8c8a433e1a29ea4912d1db4be7311" title="Submits scene control commands (API calls on RendererSceneControl) since previous flush to be execute...">flush</a> is called, they are then executed asynchronously in the renderer core, the order of execution is preserved. Most of the commands have a corresponding callback which reports the result back to the caller via <a class="el" href="classramses_1_1RendererSceneControl.html#a78bb4710634109f444c018149b54dd92" title="RendererSceneControl methods push commands to an internal queue which is submitted when calling flush...">dispatchEvents</a>. Some commands can fail immediately by returning a status with value other than StatusOK, in such case there will be no callback, because the command will not even be submitted. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ramses-example-local-client_2src_2main_8cpp-example.html#_a10">ramses-example-local-client/src/main.cpp</a>, <a class="el" href="ramses-example-local-pick-handling_2src_2main_8cpp-example.html#_a8">ramses-example-local-pick-handling/src/main.cpp</a>, and <a class="el" href="ramses-example-local-scene-referencing_2src_2main_8cpp-example.html#_a81">ramses-example-local-scene-referencing/src/main.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a47395ff51c80461e50a4fe3eb449d924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47395ff51c80461e50a4fe3eb449d924">&#9670;&nbsp;</a></span>RendererSceneControl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ramses::RendererSceneControl::RendererSceneControl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted default constructor. </p>

</div>
</div>
<a id="a5e4c8ef6e0a37d581d08bc7064304ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4c8ef6e0a37d581d08bc7064304ae8">&#9670;&nbsp;</a></span>RendererSceneControl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ramses::RendererSceneControl::RendererSceneControl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classramses_1_1RendererSceneControl.html">RendererSceneControl</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a78bb4710634109f444c018149b54dd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78bb4710634109f444c018149b54dd92">&#9670;&nbsp;</a></span>dispatchEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RendererSceneControl::dispatchEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html">IRendererSceneControlEventHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>eventHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">RendererSceneControl</a> methods push commands to an internal queue which is submitted when calling <a class="el" href="classramses_1_1RendererSceneControl.html#afae8c8a433e1a29ea4912d1db4be7311" title="Submits scene control commands (API calls on RendererSceneControl) since previous flush to be execute...">flush</a>. The commands are then executed during a render loop (<a class="el" href="classramses_1_1RamsesRenderer.html#a8bceaf9ed2fd659a05d2b12645a6bfdd" title="Prepare content to be rendered in next frame and render next frame. This function can not be used in ...">ramses::RamsesRenderer::doOneLoop</a> or in a render thread if used <a class="el" href="classramses_1_1RamsesRenderer.html#a90489cf440602591c90f7a08bb5958ab" title="Runs the renderer loop in a separate thread created and owned by the renderer. This function can not ...">ramses::RamsesRenderer::startThread</a>). Some of these calls result in an event (can be both informational and data). Such events and their result can be retrieved using the dispatchEvents call. <a class="el" href="classramses_1_1Scene.html" title="The Scene holds a scene graph. It is the essential class for distributing content to the ramses syste...">Scene</a> control events should be regularly consumed by calling <a class="el" href="classramses_1_1RendererSceneControl.html#a78bb4710634109f444c018149b54dd92" title="RendererSceneControl methods push commands to an internal queue which is submitted when calling flush...">dispatchEvents</a> in order to prevent buffer overflow of the internal event queue, even if the application is not interested in those events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventHandler</td><td>User class that implements the callbacks that can be triggered if a corresponding event happened. Check <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html" title="Provides an interface for handling the result of renderer scene control events. Implementation of thi...">ramses::IRendererSceneControlEventHandler</a> documentation for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="afae8c8a433e1a29ea4912d1db4be7311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae8c8a433e1a29ea4912d1db4be7311">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RendererSceneControl::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits scene control commands (API calls on <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">RendererSceneControl</a>) since previous flush to be executed in the next renderer update loop. This mechanism allows for 'atomic' changes that are applied within a single update loop, thus a single rendered frame. For example one scene can be hidden, another scene shown and data linked, all within single frame. Not all state changes can be executed within a single update loop, see <a class="el" href="classramses_1_1RendererSceneControl.html#a3a67e00fdc6770676e44f1bc254604a0" title="Request state change of a scene. ">setSceneState</a> for details. </p>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ramses-example-local-scene-referencing_2src_2main_8cpp-example.html#a83">ramses-example-local-scene-referencing/src/main.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a6420e4d8b2754d6ac8831a3bda9233bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6420e4d8b2754d6ac8831a3bda9233bb">&#9670;&nbsp;</a></span>handlePickEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RendererSceneControl::handlePickEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bufferNormalizedCoordX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bufferNormalizedCoordY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger renderer to test if given pick event with coordinates intersects with any instances of <a class="el" href="classramses_1_1PickableObject.html" title="PickableObject provides a way to specify a &#39;pickable&#39; area. ">ramses::PickableObject</a> contained in given scene. If so, the intersected PickableObjects are reported to <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">ramses::RendererSceneControl</a> (see ramses::IRendererEventHandler::objectsPicked) using their user IDs given at creation time (see <a class="el" href="classramses_1_1Scene.html#a124cab244a81f0558d3c68ad339d3478" title="Create a PickableObject. ">ramses::Scene::createPickableObject</a>). </p>
<h1><a class="anchor" id="PickCoordinates"></a>
PickCoordinates</h1>
<p>Coordinates normalized to range &lt;-1, 1&gt; where (-1, -1) is bottom left corner of the buffer where scene is mapped to and (1, 1) is top right corner. If the scene to test is rendered directly to framebuffer then display size should be used, i.e. (-1, -1) is bottom left corner of the display and (1, 1) top right corner of display. If the scene is mapped to an offscreen buffer and rendered as a texture mapped on a mesh in another scene, the given coordinates need to be mapped to the offscreen buffer dimensions in the same way. For example if the scene's offscreen buffer is mapped on a 2D quad placed somewhere on screen then the coordinates provided need to be within the region of the 2D quad, i.e. (-1, -1) at bottom left corner of the quad and (1, 1) at top right corner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>Id of scene to check for intersected PickableObjects. </td></tr>
    <tr><td class="paramname">bufferNormalizedCoordX</td><td>Normalized X pick coordinate within buffer size (see <a class="el" href="classramses_1_1RendererSceneControl.html#PickCoordinates">PickCoordinates</a>). </td></tr>
    <tr><td class="paramname">bufferNormalizedCoordY</td><td>Normalized Y pick coordinate within buffer size (see <a class="el" href="classramses_1_1RendererSceneControl.html#PickCoordinates">PickCoordinates</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="af4a77700e389a32581ad1b274552b010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a77700e389a32581ad1b274552b010">&#9670;&nbsp;</a></span>linkData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RendererSceneControl::linkData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>providerSceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab41878ab3cb9b206b58f32437faddd7f">dataProviderId_t</a>&#160;</td>
          <td class="paramname"><em>providerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>consumerSceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a>&#160;</td>
          <td class="paramname"><em>consumerId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Links a data provider from one scene to a data consumer in another scene. </p>
<p>Linking data means that the consumer's data property will be overridden by provider's data property. Consumer can be linked to only one provider, a provider can be linked to multiple consumers. <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a4decbb725ad779954dbcdad427fd6206" title="This method will be called when the data link between a data provider and data consumer is establishe...">ramses::IRendererSceneControlEventHandler::dataLinked</a> will be emitted after the link is established. The link will fail (reported via callback result argument) if either the provider or consumer does not exist or their data type does not match. For some types of data links (texture linking) both the scenes have to be in state <a class="el" href="namespaceramses.html#aee996152a40d451bbbefff0ae96c66d3ae7d31fc0602fb2ede144d18cdffd816b" title="Request content to be prepare to be shown at any time. ">RendererSceneState::Ready</a>. If successful the operation can be assumed to be effective in the next frame consumer scene is rendered after flushed. If the data consumer is already linked to a provider (data or offscreen buffer), the old link will be discarded, however if the new link fails it is undefined whether previous link was discarded or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">providerSceneId</td><td>Provider scene containing provided data. </td></tr>
    <tr><td class="paramname">providerId</td><td>ID of provided data. </td></tr>
    <tr><td class="paramname">consumerSceneId</td><td>Consumer scene containing consumer slot. </td></tr>
    <tr><td class="paramname">consumerId</td><td>ID of consumer slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. StatusOK does not guarantee success, the result argument in dispatched event has its own status. </dd></dl>

</div>
</div>
<a id="a404275629b0b73ad04d10f4a1649e8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404275629b0b73ad04d10f4a1649e8ba">&#9670;&nbsp;</a></span>linkOffscreenBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RendererSceneControl::linkOffscreenBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td>
          <td class="paramname"><em>offscreenBufferId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>consumerSceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a>&#160;</td>
          <td class="paramname"><em>consumerDataSlotId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Links display's offscreen buffer to a data consumer in scene. </p>
<p>This is a special case of Ramses data linking where offscreen buffer acts as texture provider. Offscreen buffer can be used as texture data in one or more scene's texture sampler(s) (<a class="el" href="classramses_1_1Scene.html#afcd023e6f43a8143b567cb2551860a5d" title="Annotates a TextureSampler as a content consumer. Texture provider and texture consumer can be linked...">ramses::Scene::createTextureConsumer</a>). For successful link, the consumer scene must be <a class="el" href="namespaceramses.html#aee996152a40d451bbbefff0ae96c66d3ae7d31fc0602fb2ede144d18cdffd816b" title="Request content to be prepare to be shown at any time. ">RendererSceneState::Ready</a> or <a class="el" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82caa15a459a0439bde1ab6508bce7a05547" title="Scene is being rendered. ">RendererSceneState::Rendered</a> and has to be mapped (<a class="el" href="classramses_1_1RendererSceneControl.html#a4065e5ff1fad466e3524022a368711d9" title="Set scene display mapping. ">setSceneMapping</a>) to the same display that the offscreen buffer belongs to. If the data consumer is already linked to a provider (data or offscreen buffer), the old link will be discarded, however if the new link fails it is undefined whether previous link was discarded or not. Note: To unlink offscreen buffer use <a class="el" href="classramses_1_1RendererSceneControl.html#a3705492a690fa9ec03ce9f5a50e74994" title="Removes an existing link between data provider and consumer (linkData) or offscreen buffer and consum...">unlinkData</a> as with any other type of data linking.</p>
<p><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#ac016d8f7c0e6ab084f6a8c86481b9288" title="This method will be called when the data link between offscreen buffer and scene&#39;s data slot is estab...">ramses::IRendererSceneControlEventHandler::offscreenBufferLinked</a> will be emitted after offscreen buffer linked to consumer. If successful the operation can be assumed to be effective in the next frame consumer scene is rendered after flushed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offscreenBufferId</td><td>ID of the offscreen buffer to use as texture provider. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">consumerSceneId</td><td><a class="el" href="classramses_1_1Scene.html" title="The Scene holds a scene graph. It is the essential class for distributing content to the ramses syste...">Scene</a> which consumes the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">consumerDataSlotId</td><td>Data consumer within the consumer scene (<a class="el" href="classramses_1_1Scene.html#afcd023e6f43a8143b567cb2551860a5d" title="Annotates a TextureSampler as a content consumer. Texture provider and texture consumer can be linked...">ramses::Scene::createTextureConsumer</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. StatusOK does not guarantee success, the result argument in dispatched event has its own status. </dd></dl>

</div>
</div>
<a id="a9def7e1bd04213343d90553860ba4ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9def7e1bd04213343d90553860ba4ae9">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classramses_1_1RendererSceneControl.html">RendererSceneControl</a>&amp; ramses::RendererSceneControl::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classramses_1_1RendererSceneControl.html">RendererSceneControl</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>unused </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unused </dd></dl>

</div>
</div>
<a id="a865b4e80546bf49191ec6307f0c39b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865b4e80546bf49191ec6307f0c39b17">&#9670;&nbsp;</a></span>setSceneDisplayBufferAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RendererSceneControl::setSceneDisplayBufferAssignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td>
          <td class="paramname"><em>displayBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sceneRenderOrder</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set scene display buffer assignment. </p>
<p>When scene's display mapping is set (<a class="el" href="classramses_1_1RendererSceneControl.html#a4065e5ff1fad466e3524022a368711d9" title="Set scene display mapping. ">setSceneMapping</a>) the scene can only be rendered in the context of that display, either into display's framebuffer or an offscreen buffer belonging to that display. Explicit assignment is not required for a scene to be rendered, a default assignment will be used then which is display's framebuffer. A display always has a framebuffer, its display buffer ID can be obtained via <a class="el" href="classramses_1_1RamsesRenderer.html#addff71feff4e101e665631b6b27363a6" title="Get display&#39;s framebuffer ID. Every display upon creation has one framebuffer which can be referenced...">ramses::RamsesRenderer::getDisplayFramebuffer</a>. Unlike display mapping the assignment to a display buffer can be changed in any of the scene's states, the only requirement is that a valid display mapping was previously set (<a class="el" href="classramses_1_1RendererSceneControl.html#a4065e5ff1fad466e3524022a368711d9" title="Set scene display mapping. ">setSceneMapping</a>).</p>
<p>Assigning a scene to display buffer changes the way its render order is determined. The render order of following buffer groups is fixed:</p><ol type="1">
<li>Offscreen buffers</li>
<li>Framebuffer</li>
<li>Interruptible offscreen buffers So the scene render order only affects the sorting within its corresponding group.</li>
</ol>
<p>There is no event callback for this operation, the assignment can be assumed to be effective in the next frame scene is rendered after flushed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sceneId</td><td><a class="el" href="classramses_1_1Scene.html" title="The Scene holds a scene graph. It is the essential class for distributing content to the ramses syste...">Scene</a> to assign to given display buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">displayBuffer</td><td>Id of display buffer (framebuffer or offscreen buffer) the scene should be assigned to. If provided buffer Id is invalid, framebuffer of display where scene is mapped is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sceneRenderOrder</td><td>Lower value means that a scene is rendered before a scene with higher value. Default is 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a4065e5ff1fad466e3524022a368711d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4065e5ff1fad466e3524022a368711d9">&#9670;&nbsp;</a></span>setSceneMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RendererSceneControl::setSceneMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>displayId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set scene display mapping. </p>
<p>Every scene has to be mapped to a display first in order to render it on that display. This is crucial for the renderer to know how to manage scene's resources, namely which rendering context to upload them to. A valid scene mapping is a prerequisite for a request to change scene's state to <a class="el" href="namespaceramses.html#aee996152a40d451bbbefff0ae96c66d3ae7d31fc0602fb2ede144d18cdffd816b" title="Request content to be prepare to be shown at any time. ">RendererSceneState::Ready</a> or <a class="el" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82caa15a459a0439bde1ab6508bce7a05547" title="Scene is being rendered. ">RendererSceneState::Rendered</a>.</p>
<p><a class="el" href="classramses_1_1Scene.html" title="The Scene holds a scene graph. It is the essential class for distributing content to the ramses syste...">Scene</a>'s display mapping can only be changed if scene is in a state below <a class="el" href="namespaceramses.html#aee996152a40d451bbbefff0ae96c66d3ae7d31fc0602fb2ede144d18cdffd816b" title="Request content to be prepare to be shown at any time. ">RendererSceneState::Ready</a> and not yet requested to switch its state to Ready/Rendered. Setting a scene mapping resets display buffer assignment to its default (framebuffer), see <a class="el" href="classramses_1_1RendererSceneControl.html#a865b4e80546bf49191ec6307f0c39b17" title="Set scene display buffer assignment. ">setSceneDisplayBufferAssignment</a>.</p>
<p>Given display ID must refer to an existing display at the time of scene being mapped to that display, i.e. when its state transition to <a class="el" href="namespaceramses.html#aee996152a40d451bbbefff0ae96c66d3ae7d31fc0602fb2ede144d18cdffd816b" title="Request content to be prepare to be shown at any time. ">RendererSceneState::Ready</a> is executed.</p>
<p>There is no event callback for this operation, the mapping is set immediately and will be used when executing scene state transition to <a class="el" href="namespaceramses.html#aee996152a40d451bbbefff0ae96c66d3ae7d31fc0602fb2ede144d18cdffd816b" title="Request content to be prepare to be shown at any time. ">RendererSceneState::Ready</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sceneId</td><td><a class="el" href="classramses_1_1Scene.html" title="The Scene holds a scene graph. It is the essential class for distributing content to the ramses syste...">Scene</a> to set display mapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">displayId</td><td>Display to set as target for scene when mapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ramses-example-local-scene-referencing_2src_2main_8cpp-example.html#a82">ramses-example-local-scene-referencing/src/main.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a3a67e00fdc6770676e44f1bc254604a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a67e00fdc6770676e44f1bc254604a0">&#9670;&nbsp;</a></span>setSceneState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RendererSceneControl::setSceneState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82c">RendererSceneState</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request state change of a scene. </p>
<p>Ramses scenes are containers carrying content data from client, apart from the content state there is also a rendering state of a scene on renderer side, see <a class="el" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82c">RendererSceneState</a> for description of the states. Any scene state can be requested even if scene was not yet published, internal logic will start state transitions automatically as soon as scene gets published and will emit corresponding state change callbacks for each transition. A valid display mapping has to be set (<a class="el" href="classramses_1_1RendererSceneControl.html#a4065e5ff1fad466e3524022a368711d9" title="Set scene display mapping. ">setSceneMapping</a>) before requesting a scene to be <a class="el" href="namespaceramses.html#aee996152a40d451bbbefff0ae96c66d3ae7d31fc0602fb2ede144d18cdffd816b" title="Request content to be prepare to be shown at any time. ">RendererSceneState::Ready</a> or <a class="el" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82caa15a459a0439bde1ab6508bce7a05547" title="Scene is being rendered. ">RendererSceneState::Rendered</a>, otherwise this request will fail.</p>
<p>State change request when executed results in a state change callback. If and only if there was an actual scene state change executed in the renderer a <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a6d004040870b94940f0a67b843672f83" title="This method will be called when state of a scene changes. ">ramses::IRendererSceneControlEventHandler::sceneStateChanged</a> is emitted.</p>
<p>Only these transitions are guaranteed to be fully executed in the very next frame after calling <a class="el" href="classramses_1_1RendererSceneControl.html#afae8c8a433e1a29ea4912d1db4be7311" title="Submits scene control commands (API calls on RendererSceneControl) since previous flush to be execute...">flush</a> : <a class="el" href="namespaceramses.html#aee996152a40d451bbbefff0ae96c66d3ae7d31fc0602fb2ede144d18cdffd816b" title="Request content to be prepare to be shown at any time. ">RendererSceneState::Ready</a> -&gt; <a class="el" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82caa15a459a0439bde1ab6508bce7a05547" title="Scene is being rendered. ">RendererSceneState::Rendered</a> (start rendering) <a class="el" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82caa15a459a0439bde1ab6508bce7a05547" title="Scene is being rendered. ">RendererSceneState::Rendered</a> -&gt; <a class="el" href="namespaceramses.html#aee996152a40d451bbbefff0ae96c66d3ae7d31fc0602fb2ede144d18cdffd816b" title="Request content to be prepare to be shown at any time. ">RendererSceneState::Ready</a> (stop rendering)</p>
<p>On the other hand a transition to <a class="el" href="namespaceramses.html#aee996152a40d451bbbefff0ae96c66d3ae7d31fc0602fb2ede144d18cdffd816b" title="Request content to be prepare to be shown at any time. ">RendererSceneState::Ready</a> from any of the lower states should be expected to take longer time (potentially multiple update loops) due to the need of uploading scene's resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sceneId</td><td><a class="el" href="classramses_1_1Scene.html" title="The Scene holds a scene graph. It is the essential class for distributing content to the ramses syste...">Scene</a> to request state change for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td><a class="el" href="classramses_1_1Scene.html" title="The Scene holds a scene graph. It is the essential class for distributing content to the ramses syste...">Scene</a> state to request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. StatusOK does not guarantee success, the result argument in dispatched event has its own status. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ramses-example-local-scene-referencing_2src_2main_8cpp-example.html#a87">ramses-example-local-scene-referencing/src/main.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a3705492a690fa9ec03ce9f5a50e74994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3705492a690fa9ec03ce9f5a50e74994">&#9670;&nbsp;</a></span>unlinkData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RendererSceneControl::unlinkData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>consumerSceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a>&#160;</td>
          <td class="paramname"><em>consumerId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an existing link between data provider and consumer (<a class="el" href="classramses_1_1RendererSceneControl.html#af4a77700e389a32581ad1b274552b010" title="Links a data provider from one scene to a data consumer in another scene. ">linkData</a>) or offscreen buffer and consumer (<a class="el" href="classramses_1_1RendererSceneControl.html#a404275629b0b73ad04d10f4a1649e8ba" title="Links display&#39;s offscreen buffer to a data consumer in scene. ">linkOffscreenBuffer</a>). </p>
<p>Data link is fully defined by consumer scene and its data slot as there can only be one link from consumer to provider. <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#afe4c204c021ddeee45297b7e63275e1b" title="This method will be called when the data link between a data provider and data consumer is destroyed...">ramses::IRendererSceneControlEventHandler::dataUnlinked</a> will be emitted after consumer unlinked from provider. If successful the operation can be assumed to be effective in the next frame consumer scene is rendered after flushed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">consumerSceneId</td><td>Consumer scene containing consumer slot. </td></tr>
    <tr><td class="paramname">consumerId</td><td>ID of consumer slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. StatusOK does not guarantee success, the result argument in dispatched event has its own status. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ace582ac764d79427772152785e51845b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace582ac764d79427772152785e51845b">&#9670;&nbsp;</a></span>RamsesRendererImpl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class RamsesRendererImpl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classramses_1_1RendererSceneControl__legacy.html" title="Control states of scenes. ">RendererSceneControl_legacy</a> can only be instantiated through <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a60c4e15091952c047f530de2c6ba9c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c4e15091952c047f530de2c6ba9c11">&#9670;&nbsp;</a></span>impl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class RendererSceneControlImpl&amp; ramses::RendererSceneControl::impl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores internal data for implementation specifics. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/ramses/dev/oss-ramses/renderer/RendererLib/ramses-renderer-api/include/ramses-renderer-api/<a class="el" href="RendererSceneControl_8h_source.html">RendererSceneControl.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
