<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAMSES Documentation: ramses::RamsesRenderer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ramses_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RAMSES Documentation
   &#160;<span id="projectnumber">25.0.6</span>
   </div>
   <div id="projectbrief">Information for RAMSES users and developers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceramses.html">ramses</a></li><li class="navelem"><a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classramses_1_1RamsesRenderer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ramses::RamsesRenderer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a> is the main renderer component which provides API to configure and control the way content will be rendered on display(s).  
 <a href="classramses_1_1RamsesRenderer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RamsesRenderer_8h_source.html">RamsesRenderer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ramses::RamsesRenderer:</div>
<div class="dyncontent">
<div class="center"><img src="classramses_1_1RamsesRenderer__inherit__graph.png" border="0" usemap="#ramses_1_1RamsesRenderer_inherit__map" alt="Inheritance graph"/></div>
<map name="ramses_1_1RamsesRenderer_inherit__map" id="ramses_1_1RamsesRenderer_inherit__map">
<area shape="rect" id="node2" href="classramses_1_1StatusObject.html" title="The StatusObject provides status message handling. " alt="" coords="18,5,167,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ramses::RamsesRenderer:</div>
<div class="dyncontent">
<div class="center"><img src="classramses_1_1RamsesRenderer__coll__graph.png" border="0" usemap="#ramses_1_1RamsesRenderer_coll__map" alt="Collaboration graph"/></div>
<map name="ramses_1_1RamsesRenderer_coll__map" id="ramses_1_1RamsesRenderer_coll__map">
<area shape="rect" id="node2" href="classramses_1_1StatusObject.html" title="The StatusObject provides status message handling. " alt="" coords="18,5,167,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8bceaf9ed2fd659a05d2b12645a6bfdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a8bceaf9ed2fd659a05d2b12645a6bfdd">doOneLoop</a> ()</td></tr>
<tr class="memdesc:a8bceaf9ed2fd659a05d2b12645a6bfdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare content to be rendered in next frame and render next frame. This function can not be used in combination with startThread, stopThread and setMaximumFramerate.  <a href="#a8bceaf9ed2fd659a05d2b12645a6bfdd">More...</a><br /></td></tr>
<tr class="separator:a8bceaf9ed2fd659a05d2b12645a6bfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90489cf440602591c90f7a08bb5958ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a90489cf440602591c90f7a08bb5958ab">startThread</a> ()</td></tr>
<tr class="memdesc:a90489cf440602591c90f7a08bb5958ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the renderer loop in a separate thread created and owned by the renderer. This function can not be used in combination with doOneLoop.  <a href="#a90489cf440602591c90f7a08bb5958ab">More...</a><br /></td></tr>
<tr class="separator:a90489cf440602591c90f7a08bb5958ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01dd58f37a2a782bcb77e25bea81175c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a01dd58f37a2a782bcb77e25bea81175c">stopThread</a> ()</td></tr>
<tr class="memdesc:a01dd58f37a2a782bcb77e25bea81175c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the thread running the renderer loop that was started by calling startThread. A call to this function joins the renderer thread to wait for its termination. This function can only be used if startThread was successfully called before.  <a href="#a01dd58f37a2a782bcb77e25bea81175c">More...</a><br /></td></tr>
<tr class="separator:a01dd58f37a2a782bcb77e25bea81175c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd3f2d1e4f5782019544a52edb8bf2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a2bd3f2d1e4f5782019544a52edb8bf2e">isThreadRunning</a> () const</td></tr>
<tr class="memdesc:a2bd3f2d1e4f5782019544a52edb8bf2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current state of render thread running.  <a href="#a2bd3f2d1e4f5782019544a52edb8bf2e">More...</a><br /></td></tr>
<tr class="separator:a2bd3f2d1e4f5782019544a52edb8bf2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96181331eab7ab60dd607a3bcab999a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a96181331eab7ab60dd607a3bcab999a6">setMaximumFramerate</a> (float maximumFramerate)</td></tr>
<tr class="memdesc:a96181331eab7ab60dd607a3bcab999a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum frame rate per second for the render loop when it is running in renderer thread using startThread. The parameter is of type float because it is possible to specify numbers between 0 and 1 as well, which will result in FPS lower than 1, e.g. 0.5.  <a href="#a96181331eab7ab60dd607a3bcab999a6">More...</a><br /></td></tr>
<tr class="separator:a96181331eab7ab60dd607a3bcab999a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d5685d38fb82c58e13f9274ce087d5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#ac8d5685d38fb82c58e13f9274ce087d5">getMaximumFramerate</a> () const</td></tr>
<tr class="memdesc:ac8d5685d38fb82c58e13f9274ce087d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current value for maximum frame rate per second set by the user. if the user did not set a value then it returs the default value.  <a href="#ac8d5685d38fb82c58e13f9274ce087d5">More...</a><br /></td></tr>
<tr class="separator:ac8d5685d38fb82c58e13f9274ce087d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2203f9f2e6a6ab233809e1ee85367d89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a2203f9f2e6a6ab233809e1ee85367d89">setLoopMode</a> (<a class="el" href="namespaceramses.html#adcfa3b1b4a623dea062782aefa84e002">ELoopMode</a> loopMode)</td></tr>
<tr class="memdesc:a2203f9f2e6a6ab233809e1ee85367d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mode of operation for render loop. This function affects the behavior of BOTH doOneLoop and startThread. Mode can be changed during run-time, in case of thread rendering also while the thread is running. By default loop mode is set to render and update.  <a href="#a2203f9f2e6a6ab233809e1ee85367d89">More...</a><br /></td></tr>
<tr class="separator:a2203f9f2e6a6ab233809e1ee85367d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af865674d0f4270c9e846a6f1b8ad2053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#adcfa3b1b4a623dea062782aefa84e002">ELoopMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#af865674d0f4270c9e846a6f1b8ad2053">getLoopMode</a> () const</td></tr>
<tr class="memdesc:af865674d0f4270c9e846a6f1b8ad2053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current value for loop mode set using setLoopMode.  <a href="#af865674d0f4270c9e846a6f1b8ad2053">More...</a><br /></td></tr>
<tr class="separator:af865674d0f4270c9e846a6f1b8ad2053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac371e5e8e6a581a8d16f39e9ece1ed99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#ac371e5e8e6a581a8d16f39e9ece1ed99">setFrameTimerLimits</a> (uint64_t limitForSceneResourcesUpload, uint64_t limitForClientResourcesUpload, uint64_t limitForOffscreenBufferRender)</td></tr>
<tr class="memdesc:ac371e5e8e6a581a8d16f39e9ece1ed99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets time limits for time-out of different sections of render and update loop.  <a href="#ac371e5e8e6a581a8d16f39e9ece1ed99">More...</a><br /></td></tr>
<tr class="separator:ac371e5e8e6a581a8d16f39e9ece1ed99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26564ba54af9e15729e43b86425826bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a26564ba54af9e15729e43b86425826bd">setPendingFlushLimits</a> (uint32_t forceApplyFlushLimit, uint32_t forceUnsubscribeSceneLimit)</td></tr>
<tr class="memdesc:a26564ba54af9e15729e43b86425826bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of pending flushes accepted before force-applying them to their scene, or forcefully insubscribing the scene.  <a href="#a26564ba54af9e15729e43b86425826bd">More...</a><br /></td></tr>
<tr class="separator:a26564ba54af9e15729e43b86425826bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1077a8cd9283f6e313d646459815c931"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a1077a8cd9283f6e313d646459815c931">setSkippingOfUnmodifiedBuffers</a> (bool enable=true)</td></tr>
<tr class="memdesc:a1077a8cd9283f6e313d646459815c931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable skipping of rendering of unmodified buffers. By default the renderer does not re-render buffers (framebuffer or offscreen buffer) if there was no change to any of the content assigned to the buffer. This can save hardware resources or free up resources for rendering of other buffers. It can be however desired to disable such optimization for profiling of worst case scenario or debugging of a graphical glitch.  <a href="#a1077a8cd9283f6e313d646459815c931">More...</a><br /></td></tr>
<tr class="separator:a1077a8cd9283f6e313d646459815c931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8715c650b5617440220f6980f8cfbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a5e8715c650b5617440220f6980f8cfbe">createDisplay</a> (const <a class="el" href="classramses_1_1DisplayConfig.html">DisplayConfig</a> &amp;config)</td></tr>
<tr class="memdesc:a5e8715c650b5617440220f6980f8cfbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a display based on provided display config. Creation of a display is an asynchronous action and the display will be created during the next render loop. The result of the createDisplay can be retrieved via dispatchEvents which will trigger a callback after the asynchronous action was processed.  <a href="#a5e8715c650b5617440220f6980f8cfbe">More...</a><br /></td></tr>
<tr class="separator:a5e8715c650b5617440220f6980f8cfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d683d3ec9bdfae4e63a27d99f9bf9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#ac1d683d3ec9bdfae4e63a27d99f9bf9e">destroyDisplay</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> displayId)</td></tr>
<tr class="memdesc:ac1d683d3ec9bdfae4e63a27d99f9bf9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a display. Destruction of a display is an asynchronous action and the actual display components (window, device, etc.) will be released during the next render loop. The result of the destroyDisplay can be retrieved via dispatchEvents which will trigger a callback with the result after the asynchronous action was processed.  <a href="#ac1d683d3ec9bdfae4e63a27d99f9bf9e">More...</a><br /></td></tr>
<tr class="separator:ac1d683d3ec9bdfae4e63a27d99f9bf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addff71feff4e101e665631b6b27363a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#addff71feff4e101e665631b6b27363a6">getDisplayFramebuffer</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> displayId) const</td></tr>
<tr class="memdesc:addff71feff4e101e665631b6b27363a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get display's framebuffer ID. Every display upon creation has one framebuffer which can be referenced by a display buffer ID to be used in various API methods that work with either a framebuffer or an offscreen buffer (e.g. RamsesRenderer::setBufferClearColor).  <a href="#addff71feff4e101e665631b6b27363a6">More...</a><br /></td></tr>
<tr class="separator:addff71feff4e101e665631b6b27363a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460bf9fc38dda88fc4af0000b2ef7fc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a460bf9fc38dda88fc4af0000b2ef7fc3">createOffscreenBuffer</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> display, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:a460bf9fc38dda88fc4af0000b2ef7fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will create an offscreen buffer that can be used to render scenes into (see RamsesRenderer::assignSceneToDisplayBuffer) and can be linked as input to a consumer texture sampler (see RamsesRenderer::linkOffscreenBufferToConsumer).  <a href="#a460bf9fc38dda88fc4af0000b2ef7fc3">More...</a><br /></td></tr>
<tr class="separator:a460bf9fc38dda88fc4af0000b2ef7fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3e4d6c6573f9333034bc2d711101b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#aba3e4d6c6573f9333034bc2d711101b0">createInterruptibleOffscreenBuffer</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> display, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:aba3e4d6c6573f9333034bc2d711101b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional API to create an offscreen buffer as interruptible. This allows the renderer to interrupt rendering of scenes to such offscreen buffer if the time budget for rendering is exceeded within a frame (see SetFrameTimerLimits). The rendering continues next frame starting from the interruption point.  <a href="#aba3e4d6c6573f9333034bc2d711101b0">More...</a><br /></td></tr>
<tr class="separator:aba3e4d6c6573f9333034bc2d711101b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e4ab2cf1d3c87290c4eeac5cd207e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a92e4ab2cf1d3c87290c4eeac5cd207e8">destroyOffscreenBuffer</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> display, <a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> offscreenBuffer)</td></tr>
<tr class="memdesc:a92e4ab2cf1d3c87290c4eeac5cd207e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will destroy a previously created offscreen buffer. If there are any consumer texture samplers linked to this buffer, these links will be removed. Offscreen buffer will fail to be destroyed if there are any scenes assigned to it, these scenes have to be first assigned to another buffer or framebuffer or unmapped from display.  <a href="#a92e4ab2cf1d3c87290c4eeac5cd207e8">More...</a><br /></td></tr>
<tr class="separator:a92e4ab2cf1d3c87290c4eeac5cd207e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615fece250e98bdfde5fae979b55b24e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a615fece250e98bdfde5fae979b55b24e">setDisplayBufferClearColor</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> display, <a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> displayBuffer, float r, float g, float b, float a)</td></tr>
<tr class="memdesc:a615fece250e98bdfde5fae979b55b24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets clear color of a display buffer (display's framebuffer or offscreen buffer).  <a href="#a615fece250e98bdfde5fae979b55b24e">More...</a><br /></td></tr>
<tr class="separator:a615fece250e98bdfde5fae979b55b24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b8b49e394f9676224f6a55e6413862"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a88b8b49e394f9676224f6a55e6413862">readPixels</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> displayId, <a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> displayBuffer, uint32_t x, uint32_t y, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:a88b8b49e394f9676224f6a55e6413862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers an asynchronous read back of a display buffer memory from GPU to system memory.  <a href="#a88b8b49e394f9676224f6a55e6413862">More...</a><br /></td></tr>
<tr class="separator:a88b8b49e394f9676224f6a55e6413862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca664b15215a8cb1f410db4da3c65296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classramses_1_1RendererSceneControl.html">RendererSceneControl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#aca664b15215a8cb1f410db4da3c65296">getSceneControlAPI</a> ()</td></tr>
<tr class="memdesc:aca664b15215a8cb1f410db4da3c65296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get scene control API.  <a href="#aca664b15215a8cb1f410db4da3c65296">More...</a><br /></td></tr>
<tr class="separator:aca664b15215a8cb1f410db4da3c65296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3d3a5cfd2d3662d50554c416fcabad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classramses_1_1RendererSceneControl__legacy.html">RendererSceneControl_legacy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#abd3d3a5cfd2d3662d50554c416fcabad">getSceneControlAPI_legacy</a> ()</td></tr>
<tr class="memdesc:abd3d3a5cfd2d3662d50554c416fcabad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get scene control API.  <a href="#abd3d3a5cfd2d3662d50554c416fcabad">More...</a><br /></td></tr>
<tr class="separator:abd3d3a5cfd2d3662d50554c416fcabad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dd9cd8d1586069f961bb367a61058b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classramses_1_1DcsmContentControl.html">DcsmContentControl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a45dd9cd8d1586069f961bb367a61058b">createDcsmContentControl</a> (const <a class="el" href="classramses_1_1DcsmContentControlConfig.html">DcsmContentControlConfig</a> &amp;config)</td></tr>
<tr class="memdesc:a45dd9cd8d1586069f961bb367a61058b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> to control content states.  <a href="#a45dd9cd8d1586069f961bb367a61058b">More...</a><br /></td></tr>
<tr class="separator:a45dd9cd8d1586069f961bb367a61058b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6732097772becc5818ba94f7aa845a10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a6732097772becc5818ba94f7aa845a10">setSurfaceVisibility</a> (uint32_t surfaceId, bool visibility)</td></tr>
<tr class="memdesc:a6732097772becc5818ba94f7aa845a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set visibility of given surface at the system compositor.  <a href="#a6732097772becc5818ba94f7aa845a10">More...</a><br /></td></tr>
<tr class="separator:a6732097772becc5818ba94f7aa845a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254d5d21f8685117aeea48cf4a26bde0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a254d5d21f8685117aeea48cf4a26bde0">setSurfaceOpacity</a> (uint32_t surfaceId, float opacity)</td></tr>
<tr class="memdesc:a254d5d21f8685117aeea48cf4a26bde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set opacity of given surface at the system compositor.  <a href="#a254d5d21f8685117aeea48cf4a26bde0">More...</a><br /></td></tr>
<tr class="separator:a254d5d21f8685117aeea48cf4a26bde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9354989524cb902ba736b2e897e5e82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#ad9354989524cb902ba736b2e897e5e82">setSurfaceRectangle</a> (uint32_t surfaceId, int32_t x, int32_t y, int32_t width, int32_t height)</td></tr>
<tr class="memdesc:ad9354989524cb902ba736b2e897e5e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set output rectangle of given surface at the system compositor.  <a href="#ad9354989524cb902ba736b2e897e5e82">More...</a><br /></td></tr>
<tr class="separator:ad9354989524cb902ba736b2e897e5e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b316650d87b61a4dbf4f8c19bd23807"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a2b316650d87b61a4dbf4f8c19bd23807">setLayerVisibility</a> (uint32_t layerId, bool visibility)</td></tr>
<tr class="memdesc:a2b316650d87b61a4dbf4f8c19bd23807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set visibility of given layer at the system compositor.  <a href="#a2b316650d87b61a4dbf4f8c19bd23807">More...</a><br /></td></tr>
<tr class="separator:a2b316650d87b61a4dbf4f8c19bd23807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6dd092a73ecf218c36a6dffaddbea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a0e6dd092a73ecf218c36a6dffaddbea0">takeSystemCompositorScreenshot</a> (const char *fileName, int32_t screenIviId)</td></tr>
<tr class="memdesc:a0e6dd092a73ecf218c36a6dffaddbea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger the System Compositor to take a screenshot and store it in a file.  <a href="#a0e6dd092a73ecf218c36a6dffaddbea0">More...</a><br /></td></tr>
<tr class="separator:a0e6dd092a73ecf218c36a6dffaddbea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ef2b5e6b42052bd5ad6c7a61fe78f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a56ef2b5e6b42052bd5ad6c7a61fe78f2">updateWarpingMeshData</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> displayId, const <a class="el" href="classramses_1_1WarpingMeshData.html">WarpingMeshData</a> &amp;newWarpingMeshData)</td></tr>
<tr class="memdesc:a56ef2b5e6b42052bd5ad6c7a61fe78f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the warping mesh for the warping postprocessing based on the new config.  <a href="#a56ef2b5e6b42052bd5ad6c7a61fe78f2">More...</a><br /></td></tr>
<tr class="separator:a56ef2b5e6b42052bd5ad6c7a61fe78f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aeedaa36dd7cc51bbf657298b2a0419"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a7aeedaa36dd7cc51bbf657298b2a0419">dispatchEvents</a> (<a class="el" href="classramses_1_1IRendererEventHandler.html">IRendererEventHandler</a> &amp;rendererEventHandler)</td></tr>
<tr class="memdesc:a7aeedaa36dd7cc51bbf657298b2a0419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a> methods push commands to an internal queue which is submitted when calling <a class="el" href="classramses_1_1RamsesRenderer.html#a6307f22a698040fc1f68f771a39ff253" title="Submits renderer commands (API calls on this instance of RamsesRenderer) since previous flush to be e...">RamsesRenderer::flush</a>. The commands are then executed during a render loop (<a class="el" href="classramses_1_1RamsesRenderer.html#a8bceaf9ed2fd659a05d2b12645a6bfdd" title="Prepare content to be rendered in next frame and render next frame. This function can not be used in ...">RamsesRenderer::doOneLoop</a> or in a render thread if used <a class="el" href="classramses_1_1RamsesRenderer.html#a90489cf440602591c90f7a08bb5958ab" title="Runs the renderer loop in a separate thread created and owned by the renderer. This function can not ...">RamsesRenderer::startThread</a>). Some of these calls result in an event (can be both informational and data). Such events and their result can be retrieved using the dispatchEvents call. <em>IMPORTANT</em> Renderer events must be regularly consumed by calling <a class="el" href="classramses_1_1RamsesRenderer.html#a7aeedaa36dd7cc51bbf657298b2a0419" title="Most RamsesRenderer methods push commands to an internal queue which is submitted when calling Ramses...">dispatchEvents()</a> in order to prevent buffer overflow of the internal event queue, even if the application is not interested in those events.  <a href="#a7aeedaa36dd7cc51bbf657298b2a0419">More...</a><br /></td></tr>
<tr class="separator:a7aeedaa36dd7cc51bbf657298b2a0419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6307f22a698040fc1f68f771a39ff253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a6307f22a698040fc1f68f771a39ff253">flush</a> ()</td></tr>
<tr class="memdesc:a6307f22a698040fc1f68f771a39ff253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits renderer commands (API calls on this instance of <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>) since previous flush to be executed in the next renderer update loop.  <a href="#a6307f22a698040fc1f68f771a39ff253">More...</a><br /></td></tr>
<tr class="separator:a6307f22a698040fc1f68f771a39ff253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1cdc22128187b688f9c236b0109004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a8e1cdc22128187b688f9c236b0109004">logRendererInfo</a> ()</td></tr>
<tr class="memdesc:a8e1cdc22128187b688f9c236b0109004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints detailed information about renderer state and contents to the log output.  <a href="#a8e1cdc22128187b688f9c236b0109004">More...</a><br /></td></tr>
<tr class="separator:a8e1cdc22128187b688f9c236b0109004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fec1c0331111e1f1a24f946bd961c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3">RamsesRenderer</a> (RamsesRendererImpl &amp;)</td></tr>
<tr class="memdesc:a40fec1c0331111e1f1a24f946bd961c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>.  <a href="#a40fec1c0331111e1f1a24f946bd961c3">More...</a><br /></td></tr>
<tr class="separator:a40fec1c0331111e1f1a24f946bd961c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987acea6b24d68446f4ba40300c15183"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a987acea6b24d68446f4ba40300c15183">RamsesRenderer</a> ()=delete</td></tr>
<tr class="memdesc:a987acea6b24d68446f4ba40300c15183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted default constructor.  <a href="#a987acea6b24d68446f4ba40300c15183">More...</a><br /></td></tr>
<tr class="separator:a987acea6b24d68446f4ba40300c15183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838a0662f0754430fc64d6791ddb8c7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a838a0662f0754430fc64d6791ddb8c7b">RamsesRenderer</a> (const <a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a838a0662f0754430fc64d6791ddb8c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <a href="#a838a0662f0754430fc64d6791ddb8c7b">More...</a><br /></td></tr>
<tr class="separator:a838a0662f0754430fc64d6791ddb8c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a7307221202b2c07a1637be9b84dde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#ac5a7307221202b2c07a1637be9b84dde">operator=</a> (const <a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;other)=delete</td></tr>
<tr class="memdesc:ac5a7307221202b2c07a1637be9b84dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment.  <a href="#ac5a7307221202b2c07a1637be9b84dde">More...</a><br /></td></tr>
<tr class="separator:ac5a7307221202b2c07a1637be9b84dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classramses_1_1StatusObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classramses_1_1StatusObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classramses_1_1StatusObject.html">ramses::StatusObject</a></td></tr>
<tr class="memitem:a1f22f4fa83016eb344ccb8a20c1e7921 inherit pub_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a1f22f4fa83016eb344ccb8a20c1e7921">validate</a> () const</td></tr>
<tr class="memdesc:a1f22f4fa83016eb344ccb8a20c1e7921 inherit pub_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates verbose validation of the object. Checks validity of internal values, references, states and performance warnings. Result can be obtained by calling <code><a class="el" href="classramses_1_1StatusObject.html#a9c270ef1525b1836e40a57713cbab999" title="Provides verbose report in human readable form generated by validate(). ">getValidationReport()</a></code>.  <a href="classramses_1_1StatusObject.html#a1f22f4fa83016eb344ccb8a20c1e7921">More...</a><br /></td></tr>
<tr class="separator:a1f22f4fa83016eb344ccb8a20c1e7921 inherit pub_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c270ef1525b1836e40a57713cbab999 inherit pub_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a9c270ef1525b1836e40a57713cbab999">getValidationReport</a> (<a class="el" href="namespaceramses.html#a2fe664af611fc05c4c7a487e195cceab">EValidationSeverity</a> severity=<a class="el" href="namespaceramses.html#a2fe664af611fc05c4c7a487e195cceabad806be26d26e0564001532670b1ccb6f">EValidationSeverity_Info</a>) const</td></tr>
<tr class="memdesc:a9c270ef1525b1836e40a57713cbab999 inherit pub_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides verbose report in human readable form generated by <code><a class="el" href="classramses_1_1StatusObject.html#a1f22f4fa83016eb344ccb8a20c1e7921" title="Generates verbose validation of the object. Checks validity of internal values, references, states and performance warnings. Result can be obtained by calling getValidationReport(). ">validate()</a></code>.  <a href="classramses_1_1StatusObject.html#a9c270ef1525b1836e40a57713cbab999">More...</a><br /></td></tr>
<tr class="separator:a9c270ef1525b1836e40a57713cbab999 inherit pub_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbbfea27c8eb369b1f21de42f2e88b1 inherit pub_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1">getStatusMessage</a> (<a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> status) const</td></tr>
<tr class="memdesc:a1fbbfea27c8eb369b1f21de42f2e88b1 inherit pub_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string description for a status provided by a RAMSES API function.  <a href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1">More...</a><br /></td></tr>
<tr class="separator:a1fbbfea27c8eb369b1f21de42f2e88b1 inherit pub_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7d7495b7a081aa9bc3a4b8eac36e19 inherit pub_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a0e7d7495b7a081aa9bc3a4b8eac36e19">StatusObject</a> (const <a class="el" href="classramses_1_1StatusObject.html">StatusObject</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a0e7d7495b7a081aa9bc3a4b8eac36e19 inherit pub_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <a href="classramses_1_1StatusObject.html#a0e7d7495b7a081aa9bc3a4b8eac36e19">More...</a><br /></td></tr>
<tr class="separator:a0e7d7495b7a081aa9bc3a4b8eac36e19 inherit pub_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1d8fa3051147db0ecb18c1ce500ee2 inherit pub_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classramses_1_1StatusObject.html">StatusObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a2e1d8fa3051147db0ecb18c1ce500ee2">operator=</a> (const <a class="el" href="classramses_1_1StatusObject.html">StatusObject</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a2e1d8fa3051147db0ecb18c1ce500ee2 inherit pub_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment.  <a href="classramses_1_1StatusObject.html#a2e1d8fa3051147db0ecb18c1ce500ee2">More...</a><br /></td></tr>
<tr class="separator:a2e1d8fa3051147db0ecb18c1ce500ee2 inherit pub_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a116e218cbff71ef947bdb765a7220559"><td class="memItemLeft" align="right" valign="top">class RamsesRendererImpl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a116e218cbff71ef947bdb765a7220559">impl</a></td></tr>
<tr class="separator:a116e218cbff71ef947bdb765a7220559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classramses_1_1StatusObject"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classramses_1_1StatusObject')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classramses_1_1StatusObject.html">ramses::StatusObject</a></td></tr>
<tr class="memitem:a248c9883d91fdb952853f4e46f5daca6 inherit pub_attribs_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">class StatusObjectImpl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a248c9883d91fdb952853f4e46f5daca6">impl</a></td></tr>
<tr class="separator:a248c9883d91fdb952853f4e46f5daca6 inherit pub_attribs_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad73693270161e42d1d5f034d5c74b4db"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#ad73693270161e42d1d5f034d5c74b4db">RendererFactory</a></td></tr>
<tr class="memdesc:ad73693270161e42d1d5f034d5c74b4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">RendererFactory is the factory for <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>.  <a href="#ad73693270161e42d1d5f034d5c74b4db">More...</a><br /></td></tr>
<tr class="separator:ad73693270161e42d1d5f034d5c74b4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classramses_1_1StatusObject"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classramses_1_1StatusObject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classramses_1_1StatusObject.html">ramses::StatusObject</a></td></tr>
<tr class="memitem:a19aaed5d79ca0590e38e800734e65751 inherit pro_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a19aaed5d79ca0590e38e800734e65751">StatusObject</a> (StatusObjectImpl &amp;pimpl)</td></tr>
<tr class="memdesc:a19aaed5d79ca0590e38e800734e65751 inherit pro_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <a class="el" href="classramses_1_1StatusObject.html" title="The StatusObject provides status message handling. ">StatusObject</a>.  <a href="classramses_1_1StatusObject.html#a19aaed5d79ca0590e38e800734e65751">More...</a><br /></td></tr>
<tr class="separator:a19aaed5d79ca0590e38e800734e65751 inherit pro_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdea643fe5ab0db7ad2bf888928ff48a inherit pro_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#afdea643fe5ab0db7ad2bf888928ff48a">~StatusObject</a> ()</td></tr>
<tr class="memdesc:afdea643fe5ab0db7ad2bf888928ff48a inherit pro_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the <a class="el" href="classramses_1_1StatusObject.html" title="The StatusObject provides status message handling. ">StatusObject</a>.  <a href="classramses_1_1StatusObject.html#afdea643fe5ab0db7ad2bf888928ff48a">More...</a><br /></td></tr>
<tr class="separator:afdea643fe5ab0db7ad2bf888928ff48a inherit pro_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a> is the main renderer component which provides API to configure and control the way content will be rendered on display(s). </p>
<p>All the commands in this class are put to a queue and submitted only when <a class="el" href="classramses_1_1RamsesRenderer.html#a6307f22a698040fc1f68f771a39ff253" title="Submits renderer commands (API calls on this instance of RamsesRenderer) since previous flush to be e...">RamsesRenderer::flush</a> is called, they are then executed asynchronously in the renderer core, the order of execution is preserved. Most of the commands have a corresponding callback which reports the result back to the caller via <a class="el" href="classramses_1_1RamsesRenderer.html#a7aeedaa36dd7cc51bbf657298b2a0419" title="Most RamsesRenderer methods push commands to an internal queue which is submitted when calling Ramses...">RamsesRenderer::dispatchEvents</a>. Some commands can fail immediately by returning a status with value other than StatusOK, in such case there will be no callback, because the command will not even be submitted. <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a> API is not thread-safe. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ramses-example-local-client_2src_2main_8cpp-example.html#_a8">ramses-example-local-client/src/main.cpp</a>, <a class="el" href="ramses-example-local-datalink_2src_2main_8cpp-example.html#_a63">ramses-example-local-datalink/src/main.cpp</a>, <a class="el" href="ramses-example-local-displays_2src_2main_8cpp-example.html#_a73">ramses-example-local-displays/src/main.cpp</a>, <a class="el" href="ramses-example-local-offscreenbuffer_2src_2main_8cpp-example.html#_a2">ramses-example-local-offscreenbuffer/src/main.cpp</a>, <a class="el" href="ramses-example-local-pick-handling_2src_2main_8cpp-example.html#_a25">ramses-example-local-pick-handling/src/main.cpp</a>, <a class="el" href="ramses-example-local-scene-referencing_2src_2main_8cpp-example.html#_a75">ramses-example-local-scene-referencing/src/main.cpp</a>, and <a class="el" href="ramses-example-local-viewport-link_2src_2main_8cpp-example.html#_a2">ramses-example-local-viewport-link/src/main.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a40fec1c0331111e1f1a24f946bd961c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fec1c0331111e1f1a24f946bd961c3">&#9670;&nbsp;</a></span>RamsesRenderer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ramses::RamsesRenderer::RamsesRenderer </td>
          <td>(</td>
          <td class="paramtype">RamsesRendererImpl &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>. </p>

</div>
</div>
<a id="a987acea6b24d68446f4ba40300c15183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987acea6b24d68446f4ba40300c15183">&#9670;&nbsp;</a></span>RamsesRenderer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ramses::RamsesRenderer::RamsesRenderer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted default constructor. </p>

</div>
</div>
<a id="a838a0662f0754430fc64d6791ddb8c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838a0662f0754430fc64d6791ddb8c7b">&#9670;&nbsp;</a></span>RamsesRenderer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ramses::RamsesRenderer::RamsesRenderer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>unused </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a45dd9cd8d1586069f961bb367a61058b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dd9cd8d1586069f961bb367a61058b">&#9670;&nbsp;</a></span>createDcsmContentControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classramses_1_1DcsmContentControl.html">DcsmContentControl</a>* ramses::RamsesRenderer::createDcsmContentControl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classramses_1_1DcsmContentControlConfig.html">DcsmContentControlConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> to control content states. </p>
<p><a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> can be used to control content states (a DCSM content is an abstraction for a scene). In addition <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> handles content states in the DCSM protocol context, it is essentially a combination of renderer scene control API and <a class="el" href="classramses_1_1DcsmConsumer.html" title="Class representing DCSM consumer side. ">ramses::DcsmConsumer</a>. There can be only a single instance of <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> within <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer. ">RamsesRenderer</a>. Calling this method more than once will fail. This method will return nullptr in case an internal policy disallows controlling of scenes through this API - this could mean that there is another, incompatible scene control mechanism in use. <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> has its own event dispatching mechanism, see <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> for details.</p>
<p>Obtaining the <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> will disallow usage of any other type of scene control (<a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">ramses::RendererSceneControl</a> or <a class="el" href="classramses_1_1RendererSceneControl__legacy.html" title="Control states of scenes. ">ramses::RendererSceneControl_legacy</a>). <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer. ">RamsesRenderer</a> is owner of the <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> API and the pointer stays valid as long as this <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer. ">RamsesRenderer</a> instance is alive. It cannot be destroyed without destroying the <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer. ">RamsesRenderer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Parameters to be used to instantiate the <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a>. There must be at least one DCSM category in the config in order to succeed. These are used only at instantiation time, modifications to config done later have no effect on this <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a>, or nullptr on error </dd></dl>

</div>
</div>
<a id="a5e8715c650b5617440220f6980f8cfbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8715c650b5617440220f6980f8cfbe">&#9670;&nbsp;</a></span>createDisplay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> ramses::RamsesRenderer::createDisplay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classramses_1_1DisplayConfig.html">DisplayConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a display based on provided display config. Creation of a display is an asynchronous action and the display will be created during the next render loop. The result of the createDisplay can be retrieved via dispatchEvents which will trigger a callback after the asynchronous action was processed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The display config to create and configure the new display. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Display id that can be used to refer to the created display. <a class="el" href="classramses_1_1StronglyTypedValue.html#af3fe119eff10ba4ef87f1fe6ab02f4f4" title="Static Getter for Invalid. ">displayId_t::Invalid()</a> in case of error. Display creation can still fail even if a valid display id is returned, the result of the actual creation can be retrieved via dispatchEvents. </dd></dl>

</div>
</div>
<a id="aba3e4d6c6573f9333034bc2d711101b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3e4d6c6573f9333034bc2d711101b0">&#9670;&nbsp;</a></span>createInterruptibleOffscreenBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> ramses::RamsesRenderer::createInterruptibleOffscreenBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Additional API to create an offscreen buffer as interruptible. This allows the renderer to interrupt rendering of scenes to such offscreen buffer if the time budget for rendering is exceeded within a frame (see SetFrameTimerLimits). The rendering continues next frame starting from the interruption point. </p>
<p>The renderer creates two render targets on GPU (front and back) for every interruptible offscreen buffer. It then renders into the back render target of the offscreen buffer, while it is possible to read the content of front render target with content from previous frame (or older if interrupted for several frames).</p>
<p>Note that whenever a scene gets assigned to interruptible offscreen buffer, it is not guaranteed anymore that it will be fully rendered every frame. Essentially it is rendered with lower priority.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">display</td><td>Id of display for which the buffer should be created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of the buffer to be created (has to be higher than 0 and lower than 4096) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of the buffer to be created (has to be higher than 0 and lower than 4096) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Identifier of the created offscreen buffer. In case of unsupported resolution <code><a class="el" href="classramses_1_1StronglyTypedValue.html#af3fe119eff10ba4ef87f1fe6ab02f4f4" title="Static Getter for Invalid. ">displayBufferId_t::Invalid()</a></code> will be returned with no renderer event generated. Note that the buffer will be created asynchronously and there will be a renderer event once the operation is finished. </dd></dl>

</div>
</div>
<a id="a460bf9fc38dda88fc4af0000b2ef7fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460bf9fc38dda88fc4af0000b2ef7fc3">&#9670;&nbsp;</a></span>createOffscreenBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> ramses::RamsesRenderer::createOffscreenBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will create an offscreen buffer that can be used to render scenes into (see RamsesRenderer::assignSceneToDisplayBuffer) and can be linked as input to a consumer texture sampler (see RamsesRenderer::linkOffscreenBufferToConsumer). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">display</td><td>id of display for which the buffer should be created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>width of the buffer to be created (has to be higher than 0 and lower than 4096) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>height of the buffer to be created (has to be higher than 0 and lower than 4096) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Identifier of the created offscreen buffer. In case of unsupported resolution <code><a class="el" href="classramses_1_1StronglyTypedValue.html#af3fe119eff10ba4ef87f1fe6ab02f4f4" title="Static Getter for Invalid. ">displayBufferId_t::Invalid()</a></code> will be returned with no renderer event generated. Note that the buffer will be created asynchronously and there will be a renderer event once the operation is finished. </dd></dl>

</div>
</div>
<a id="ac1d683d3ec9bdfae4e63a27d99f9bf9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d683d3ec9bdfae4e63a27d99f9bf9e">&#9670;&nbsp;</a></span>destroyDisplay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::destroyDisplay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>displayId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a display. Destruction of a display is an asynchronous action and the actual display components (window, device, etc.) will be released during the next render loop. The result of the destroyDisplay can be retrieved via dispatchEvents which will trigger a callback with the result after the asynchronous action was processed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">displayId</td><td>The display id of the display to destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a92e4ab2cf1d3c87290c4eeac5cd207e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e4ab2cf1d3c87290c4eeac5cd207e8">&#9670;&nbsp;</a></span>destroyOffscreenBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::destroyOffscreenBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td>
          <td class="paramname"><em>offscreenBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will destroy a previously created offscreen buffer. If there are any consumer texture samplers linked to this buffer, these links will be removed. Offscreen buffer will fail to be destroyed if there are any scenes assigned to it, these scenes have to be first assigned to another buffer or framebuffer or unmapped from display. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">display</td><td>id of display which the buffer belongs to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offscreenBuffer</td><td>id of buffer to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a7aeedaa36dd7cc51bbf657298b2a0419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aeedaa36dd7cc51bbf657298b2a0419">&#9670;&nbsp;</a></span>dispatchEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::dispatchEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classramses_1_1IRendererEventHandler.html">IRendererEventHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>rendererEventHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Most <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a> methods push commands to an internal queue which is submitted when calling <a class="el" href="classramses_1_1RamsesRenderer.html#a6307f22a698040fc1f68f771a39ff253" title="Submits renderer commands (API calls on this instance of RamsesRenderer) since previous flush to be e...">RamsesRenderer::flush</a>. The commands are then executed during a render loop (<a class="el" href="classramses_1_1RamsesRenderer.html#a8bceaf9ed2fd659a05d2b12645a6bfdd" title="Prepare content to be rendered in next frame and render next frame. This function can not be used in ...">RamsesRenderer::doOneLoop</a> or in a render thread if used <a class="el" href="classramses_1_1RamsesRenderer.html#a90489cf440602591c90f7a08bb5958ab" title="Runs the renderer loop in a separate thread created and owned by the renderer. This function can not ...">RamsesRenderer::startThread</a>). Some of these calls result in an event (can be both informational and data). Such events and their result can be retrieved using the dispatchEvents call. <em>IMPORTANT</em> Renderer events must be regularly consumed by calling <a class="el" href="classramses_1_1RamsesRenderer.html#a7aeedaa36dd7cc51bbf657298b2a0419" title="Most RamsesRenderer methods push commands to an internal queue which is submitted when calling Ramses...">dispatchEvents()</a> in order to prevent buffer overflow of the internal event queue, even if the application is not interested in those events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rendererEventHandler</td><td>User class that implements the callbacks that can be triggered if a corresponding event happened. Check <a class="el" href="classramses_1_1IRendererEventHandler.html" title="Provides an interface for handling the result of renderer events. Implementation of this interface mu...">ramses::IRendererEventHandler</a> documentation for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a8bceaf9ed2fd659a05d2b12645a6bfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bceaf9ed2fd659a05d2b12645a6bfdd">&#9670;&nbsp;</a></span>doOneLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::doOneLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare content to be rendered in next frame and render next frame. This function can not be used in combination with startThread, stopThread and setMaximumFramerate. </p>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a6307f22a698040fc1f68f771a39ff253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6307f22a698040fc1f68f771a39ff253">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits renderer commands (API calls on this instance of <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>) since previous flush to be executed in the next renderer update loop. </p>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="addff71feff4e101e665631b6b27363a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addff71feff4e101e665631b6b27363a6">&#9670;&nbsp;</a></span>getDisplayFramebuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> ramses::RamsesRenderer::getDisplayFramebuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>displayId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get display's framebuffer ID. Every display upon creation has one framebuffer which can be referenced by a display buffer ID to be used in various API methods that work with either a framebuffer or an offscreen buffer (e.g. RamsesRenderer::setBufferClearColor). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">displayId</td><td>The ID of display for which the framebuffer ID is being queried. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Display's framebuffer ID or invalid ID if display does not exist. </dd></dl>

</div>
</div>
<a id="af865674d0f4270c9e846a6f1b8ad2053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af865674d0f4270c9e846a6f1b8ad2053">&#9670;&nbsp;</a></span>getLoopMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#adcfa3b1b4a623dea062782aefa84e002">ELoopMode</a> ramses::RamsesRenderer::getLoopMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current value for loop mode set using setLoopMode. </p>
<dl class="section return"><dt>Returns</dt><dd>The loop mode </dd></dl>

</div>
</div>
<a id="ac8d5685d38fb82c58e13f9274ce087d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d5685d38fb82c58e13f9274ce087d5">&#9670;&nbsp;</a></span>getMaximumFramerate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ramses::RamsesRenderer::getMaximumFramerate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current value for maximum frame rate per second set by the user. if the user did not set a value then it returs the default value. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum frame rate per second </dd></dl>

</div>
</div>
<a id="aca664b15215a8cb1f410db4da3c65296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca664b15215a8cb1f410db4da3c65296">&#9670;&nbsp;</a></span>getSceneControlAPI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classramses_1_1RendererSceneControl.html">RendererSceneControl</a>* ramses::RamsesRenderer::getSceneControlAPI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get scene control API. </p>
<p>Typical application using Ramses has different components controlling the renderer (display management, frame limits and looping control, etc.) and controlling the states of content to be rendered (show/hide scene, data link, assign to display buffer, etc.). The scene control part can be obtained using this method, calling this method multiple times is allowed and will always return the same pointer, i.e. there is only a single instance per <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>. This method will return nullptr in case an internal policy disallows controlling of scenes through this API - this could mean that there is another, incompatible scene control mechanism in use. <a class="el" href="classramses_1_1Scene.html" title="The Scene holds a scene graph. It is the essential class for distributing content to the ramses syste...">Scene</a> control API has its own independent flush and event dispatching, see <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">ramses::RendererSceneControl</a> for details.</p>
<p>Obtaining the <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">ramses::RendererSceneControl</a> will disallow usage of any other type of scene control (<a class="el" href="classramses_1_1RendererSceneControl__legacy.html" title="Control states of scenes. ">ramses::RendererSceneControl_legacy</a> or <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a>). <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer. ">RamsesRenderer</a> is owner of the <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">ramses::RendererSceneControl</a> API and the pointer stays valid as long as this <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer. ">RamsesRenderer</a> instance is alive. It cannot be destroyed without destroying the <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer. ">RamsesRenderer</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to scene control API, or nullptr on error </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ramses-example-local-displays_2src_2main_8cpp-example.html#a75">ramses-example-local-displays/src/main.cpp</a>, <a class="el" href="ramses-example-local-offscreenbuffer_2src_2main_8cpp-example.html#a95">ramses-example-local-offscreenbuffer/src/main.cpp</a>, <a class="el" href="ramses-example-local-pick-handling_2src_2main_8cpp-example.html#a27">ramses-example-local-pick-handling/src/main.cpp</a>, and <a class="el" href="ramses-example-local-viewport-link_2src_2main_8cpp-example.html#a86">ramses-example-local-viewport-link/src/main.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="abd3d3a5cfd2d3662d50554c416fcabad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3d3a5cfd2d3662d50554c416fcabad">&#9670;&nbsp;</a></span>getSceneControlAPI_legacy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classramses_1_1RendererSceneControl__legacy.html">RendererSceneControl_legacy</a>* ramses::RamsesRenderer::getSceneControlAPI_legacy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get scene control API. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>[Use <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">RendererSceneControl</a> via <a class="el" href="classramses_1_1RamsesRenderer.html#aca664b15215a8cb1f410db4da3c65296" title="Get scene control API. ">RamsesRenderer::getSceneControlAPI</a> instead] </dd></dl>
<p>Typical application using Ramses has different components controlling the renderer (display management, frame limits and looping control, etc.) and controlling the states of content to be rendered (show/hide scene, data link, assign to display buffer, etc.). The scene control part can be obtained using this method, calling this method multiple times is allowed and will always return the same pointer, i.e. there is only a single instance per <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>. This method will return nullptr in case an internal policy disallows controlling of scenes through this API - this could mean that there is another, incompatible scene control mechanism in use. <a class="el" href="classramses_1_1Scene.html" title="The Scene holds a scene graph. It is the essential class for distributing content to the ramses syste...">Scene</a> control API has its own independent flush and event dispatching, see <a class="el" href="classramses_1_1RendererSceneControl__legacy.html" title="Control states of scenes. ">ramses::RendererSceneControl_legacy</a> for details.</p>
<p>Obtaining the <a class="el" href="classramses_1_1RendererSceneControl__legacy.html" title="Control states of scenes. ">ramses::RendererSceneControl_legacy</a> will disallow usage of any other type of scene control (<a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">ramses::RendererSceneControl</a> or <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a>). <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer. ">RamsesRenderer</a> is owner of the <a class="el" href="classramses_1_1RendererSceneControl__legacy.html" title="Control states of scenes. ">ramses::RendererSceneControl_legacy</a> API and the pointer stays valid as long as this <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer. ">RamsesRenderer</a> instance is alive. It cannot be destroyed without destroying the <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer. ">RamsesRenderer</a>.</p>
<p>Using of <a class="el" href="classramses_1_1RendererSceneControl__legacy.html" title="Control states of scenes. ">ramses::RendererSceneControl_legacy</a> will fail in undefined ways if any of the scenes contains a <a class="el" href="classramses_1_1SceneReference.html" title="The SceneReference object refers to another ramses scene using its sceneId. ">ramses::SceneReference</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to scene control API, or nullptr on error </dd></dl>

</div>
</div>
<a id="a2bd3f2d1e4f5782019544a52edb8bf2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd3f2d1e4f5782019544a52edb8bf2e">&#9670;&nbsp;</a></span>isThreadRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ramses::RamsesRenderer::isThreadRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current state of render thread running. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if thread is running (started and not stopped), false otherwise. </dd></dl>

</div>
</div>
<a id="a8e1cdc22128187b688f9c236b0109004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1cdc22128187b688f9c236b0109004">&#9670;&nbsp;</a></span>logRendererInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::logRendererInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints detailed information about renderer state and contents to the log output. </p>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="ac5a7307221202b2c07a1637be9b84dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a7307221202b2c07a1637be9b84dde">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a>&amp; ramses::RamsesRenderer::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>unused </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unused </dd></dl>

</div>
</div>
<a id="a88b8b49e394f9676224f6a55e6413862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b8b49e394f9676224f6a55e6413862">&#9670;&nbsp;</a></span>readPixels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::readPixels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>displayId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td>
          <td class="paramname"><em>displayBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers an asynchronous read back of a display buffer memory from GPU to system memory. </p>
<p>The color data from the provided rectangle coordinates will be read back and stored as RGBA8. If the coordinates lie outside the rendered region the result is undefined.</p>
<p>If a read pixels command is issued for a display buffer while a previous read pixels command for the same buffer was not yet executed only the last submitted read pixel command gets executed.</p>
<p>The pixel data can be obtained as a renderer event after the asynchronous read back is finished, see <a class="el" href="classramses_1_1RamsesRenderer.html#a7aeedaa36dd7cc51bbf657298b2a0419" title="Most RamsesRenderer methods push commands to an internal queue which is submitted when calling Ramses...">RamsesRenderer::dispatchEvents</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">displayId</td><td>id of display to read pixels from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">displayBuffer</td><td>Id of display buffer to read pixels from, if <a class="el" href="classramses_1_1StronglyTypedValue.html#af3fe119eff10ba4ef87f1fe6ab02f4f4" title="Static Getter for Invalid. ">ramses::displayBufferId_t::Invalid()</a> is passed then pixels are read from the display's framebuffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The starting offset in the original image (i.e. left border) in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The starting offset in the original image (i.e. lower border) in pixels. The origin of the image is supposed to be in the lower left corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The width of the read image in pixels. Must be greater than Zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The height of the read image in pixels. Must be greater than Zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. StatusOK does not guarantee successful read back, the result event has its own status. </dd></dl>

</div>
</div>
<a id="a615fece250e98bdfde5fae979b55b24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615fece250e98bdfde5fae979b55b24e">&#9670;&nbsp;</a></span>setDisplayBufferClearColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setDisplayBufferClearColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td>
          <td class="paramname"><em>displayBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets clear color of a display buffer (display's framebuffer or offscreen buffer). </p>
<p>Clear color is used to clear the whole buffer at the beginning of a rendering cycle (typically every frame). Default clear color is (0, 0, 0, 1). There is no event callback for this operation, the clear color change can be assumed to be effective in the next frame rendered after flushed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">display</td><td>Id of display that the buffer to set clear color belongs to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">displayBuffer</td><td>Id of display buffer to set clear color, if <a class="el" href="classramses_1_1StronglyTypedValue.html#af3fe119eff10ba4ef87f1fe6ab02f4f4" title="Static Getter for Invalid. ">ramses::displayBufferId_t::Invalid()</a> is passed then the clear color is set for display's framebuffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Clear color red channel value [0,1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Clear color green channel value [0,1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Clear color blue channel value [0,1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Clear color alpha channel value [0,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="ac371e5e8e6a581a8d16f39e9ece1ed99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac371e5e8e6a581a8d16f39e9ece1ed99">&#9670;&nbsp;</a></span>setFrameTimerLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setFrameTimerLimits </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>limitForSceneResourcesUpload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>limitForClientResourcesUpload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>limitForOffscreenBufferRender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets time limits for time-out of different sections of render and update loop. </p>
<p>Setting time limits for render/update loop sections instructs the renderer to monitor the amount of time consumed by the sections and interrupt their execution if the set time limit was exceeded. The time limit for every section is calculated since beginning of frame. If a section is interrupted the renderer will execute the sections in the same order in the next frame, but it will continue to execute the interrupted section(s) from the point where it stopped.</p>
<p>Since time limits are calculated relative to the start of the frame, the values set should be monotonically increasing in the order of:</p><ol type="1">
<li>Uploading client resources</li>
<li>Uploading scene resources</li>
<li>Rendering scenes mapped to interruptible offscreen buffers</li>
</ol>
<p>By default sections have infinite time limit, so renderer would not try to interrupt their execution.</p>
<p>!! IMPORTANT !! <a class="el" href="classramses_1_1Scene.html" title="The Scene holds a scene graph. It is the essential class for distributing content to the ramses syste...">Scene</a> resource actions can not be interrupted like other resources. Therefore, if this timer is exceeded, a scene will be force-unsubscribed. Use this timer with caution and merely as a sanity check, NOT as a performance measure! Scenes should not be over-using scene resources, precisely because they can not be interrupted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">limitForSceneResourcesUpload</td><td>Time limit in microseconds (since beginning of frame) for uploading scene resources to GPU </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limitForClientResourcesUpload</td><td>Time limit in microseconds (since beginning of frame) for uploading client resources to GPU </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limitForOffscreenBufferRender</td><td>Time limit in microseconds (since beginning of frame) for rendering scenes that are mapped to interruptible offscreen buffers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. StatusOK does not guarantee successful read back, the result event has its own status. </dd></dl>

</div>
</div>
<a id="a2b316650d87b61a4dbf4f8c19bd23807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b316650d87b61a4dbf4f8c19bd23807">&#9670;&nbsp;</a></span>setLayerVisibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setLayerVisibility </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>layerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visibility</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set visibility of given layer at the system compositor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerId</td><td>id identifying the layer </td></tr>
    <tr><td class="paramname">visibility</td><td>If <code>true</code> the layer's visibility will be enabled, otherwise disabled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a2203f9f2e6a6ab233809e1ee85367d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2203f9f2e6a6ab233809e1ee85367d89">&#9670;&nbsp;</a></span>setLoopMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setLoopMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#adcfa3b1b4a623dea062782aefa84e002">ELoopMode</a>&#160;</td>
          <td class="paramname"><em>loopMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the mode of operation for render loop. This function affects the behavior of BOTH doOneLoop and startThread. Mode can be changed during run-time, in case of thread rendering also while the thread is running. By default loop mode is set to render and update. </p>
<p>For more details about each loop mode check enum.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loopMode</td><td>The mode to be used for render loop.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a96181331eab7ab60dd607a3bcab999a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96181331eab7ab60dd607a3bcab999a6">&#9670;&nbsp;</a></span>setMaximumFramerate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setMaximumFramerate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maximumFramerate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum frame rate per second for the render loop when it is running in renderer thread using startThread. The parameter is of type float because it is possible to specify numbers between 0 and 1 as well, which will result in FPS lower than 1, e.g. 0.5. </p>
<p>This function can not be used in combination with doOneLoop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maximumFramerate</td><td>The maximum frame rate per second to set for the render loop.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a26564ba54af9e15729e43b86425826bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26564ba54af9e15729e43b86425826bd">&#9670;&nbsp;</a></span>setPendingFlushLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setPendingFlushLimits </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>forceApplyFlushLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>forceUnsubscribeSceneLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of pending flushes accepted before force-applying them to their scene, or forcefully insubscribing the scene. </p>
<p>RAMSES guarantees that a scene flush is only going to be rendered if all resources (textures, shaders etc.) are received and uploaded to the GPU. This allows a misbehaving client to flood a renderer with flushes which are never executed, causing the renderer to exhaust heap memory. If too many pending flushes are received and queued, they are force-applied to the scene, even if some resources are missing, thus potentially causing flickering. This method allows overriding the number of flushes after a scene is updated to the latest flush and all pending flushes wiped from memory. A low number (e.g. 1) will cause frequent flickering, whereas a high number (e.g. 100000) could cause the renderer to go out of memory. The second parameter (forceUnsubscribeSceneLimit) controls after how many pending flushes a scene is completely unsubscribed. This can be used as a protection against malicious remote scenes. It does not affect local scenes though. It is advisable to set forceUnsubscribeSceneLimit to higher number than forceApplyFlushLimit, because re-subscribing a scene is causing a lot of network traffic and unnecessary memory operations, not to mention the scene is then also not visible until re-subscribed, mapped and shown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">forceApplyFlushLimit</td><td>Number of flushes that can be pending before force applying occurs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceUnsubscribeSceneLimit</td><td>Number of flushes that can be pending before force un-subscribe occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a1077a8cd9283f6e313d646459815c931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1077a8cd9283f6e313d646459815c931">&#9670;&nbsp;</a></span>setSkippingOfUnmodifiedBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setSkippingOfUnmodifiedBuffers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable skipping of rendering of unmodified buffers. By default the renderer does not re-render buffers (framebuffer or offscreen buffer) if there was no change to any of the content assigned to the buffer. This can save hardware resources or free up resources for rendering of other buffers. It can be however desired to disable such optimization for profiling of worst case scenario or debugging of a graphical glitch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>Enable or disable the feature (enabled initially) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. StatusOK does not guarantee successful read back, the result event has its own status. </dd></dl>

</div>
</div>
<a id="a254d5d21f8685117aeea48cf4a26bde0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254d5d21f8685117aeea48cf4a26bde0">&#9670;&nbsp;</a></span>setSurfaceOpacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setSurfaceOpacity </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>surfaceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set opacity of given surface at the system compositor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaceId</td><td>id of the surface to set opacity of </td></tr>
    <tr><td class="paramname">opacity</td><td>Opacity in the range 0.0 (fully transparent) to 1.0 (fully opaque) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="ad9354989524cb902ba736b2e897e5e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9354989524cb902ba736b2e897e5e82">&#9670;&nbsp;</a></span>setSurfaceRectangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setSurfaceRectangle </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>surfaceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set output rectangle of given surface at the system compositor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaceId</td><td>id of the surface to set the rectangle for </td></tr>
    <tr><td class="paramname">x</td><td>Output position of surface along the x-axis </td></tr>
    <tr><td class="paramname">y</td><td>Output position of surface along the y-axis </td></tr>
    <tr><td class="paramname">width</td><td>Output width of surface </td></tr>
    <tr><td class="paramname">height</td><td>Output height of surface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a6732097772becc5818ba94f7aa845a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6732097772becc5818ba94f7aa845a10">&#9670;&nbsp;</a></span>setSurfaceVisibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setSurfaceVisibility </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>surfaceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visibility</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set visibility of given surface at the system compositor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaceId</td><td>id of the surface to set visibility of </td></tr>
    <tr><td class="paramname">visibility</td><td>visibility to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a90489cf440602591c90f7a08bb5958ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90489cf440602591c90f7a08bb5958ab">&#9670;&nbsp;</a></span>startThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::startThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the renderer loop in a separate thread created and owned by the renderer. This function can not be used in combination with doOneLoop. </p>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ramses-example-local-scene-referencing_2src_2main_8cpp-example.html#a77">ramses-example-local-scene-referencing/src/main.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a01dd58f37a2a782bcb77e25bea81175c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01dd58f37a2a782bcb77e25bea81175c">&#9670;&nbsp;</a></span>stopThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::stopThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the thread running the renderer loop that was started by calling startThread. A call to this function joins the renderer thread to wait for its termination. This function can only be used if startThread was successfully called before. </p>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a0e6dd092a73ecf218c36a6dffaddbea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6dd092a73ecf218c36a6dffaddbea0">&#9670;&nbsp;</a></span>takeSystemCompositorScreenshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::takeSystemCompositorScreenshot </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>screenIviId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger the System Compositor to take a screenshot and store it in a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>File name including path, for storing the screenshot. </td></tr>
    <tr><td class="paramname">screenIviId</td><td>&gt;= 0 to trigger a screenshot on the given IVI screen id, -1 to trigger screenshot on a single existing screen (fails asynchronously if more than one screen exists) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a56ef2b5e6b42052bd5ad6c7a61fe78f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ef2b5e6b42052bd5ad6c7a61fe78f2">&#9670;&nbsp;</a></span>updateWarpingMeshData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::updateWarpingMeshData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>displayId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classramses_1_1WarpingMeshData.html">WarpingMeshData</a> &amp;&#160;</td>
          <td class="paramname"><em>newWarpingMeshData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the warping mesh for the warping postprocessing based on the new config. </p>
<p>Display must be created with warping enabled in order for this operation to succeed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">displayId</td><td>id of display to update. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newWarpingMeshData</td><td>Holds the geometry needed to create the mesh for display warping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function. ">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad73693270161e42d1d5f034d5c74b4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73693270161e42d1d5f034d5c74b4db">&#9670;&nbsp;</a></span>RendererFactory</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class RendererFactory</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>RendererFactory is the factory for <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a116e218cbff71ef947bdb765a7220559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116e218cbff71ef947bdb765a7220559">&#9670;&nbsp;</a></span>impl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class RamsesRendererImpl&amp; ramses::RamsesRenderer::impl</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores internal data for implementation specifics of <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/q479079/sources/ramses-oss/renderer/RendererLib/ramses-renderer-api/include/ramses-renderer-api/<a class="el" href="RamsesRenderer_8h_source.html">RamsesRenderer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
