<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAMSES Documentation: Exemplary API snippets</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ramses_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RAMSES Documentation
   &#160;<span id="projectnumber">25.0.1</span>
   </div>
   <div id="projectbrief">Information for RAMSES users and developers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Exemplary API snippets </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>RAMSES API Usage by Example</h1>
<p>Note: The following example code snippets</p><ul>
<li>omit error checking to keep code snippets small</li>
<li>do not represent full applications</li>
</ul>
<p>The full source code of the examples is available in examples section of this document.</p>
<h2>Minimal</h2>
<p>This client implements the minimal requirements for a client to provide content within the RAMSES distributed system. </p><div class="fragment"><div class="line">    <span class="comment">// register at RAMSES daemon</span></div><div class="line">    <a class="code" href="classramses_1_1RamsesFramework.html">ramses::RamsesFramework</a> framework(argc, argv);</div><div class="line">    <a class="code" href="classramses_1_1RamsesClient.html">ramses::RamsesClient</a>&amp; <a class="code" href="namespaceramses.html">ramses</a>(*framework.createClient(<span class="stringliteral">&quot;ramses-example-minimal&quot;</span>));</div><div class="line">    framework.connect();</div><div class="line"></div><div class="line">    <span class="comment">// create a scene and register it at RAMSES daemon</span></div><div class="line">    <a class="code" href="classramses_1_1Scene.html">ramses::Scene</a>* scene = <a class="code" href="namespaceramses.html">ramses</a>.createScene(<a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::sceneId_t</a>(123u));</div><div class="line"></div><div class="line">    <span class="comment">// signal the scene it is in a state that can be rendered</span></div><div class="line">    scene-&gt;<a class="code" href="classramses_1_1Scene.html#ac12e7548df54a23bc10c1e5629c1aa88">flush</a>();</div><div class="line"></div><div class="line">    <span class="comment">// distribute the scene to RAMSES</span></div><div class="line">    scene-&gt;<a class="code" href="classramses_1_1Scene.html#a495b0efc631c28c15b818f5c765dbbba">publish</a>();</div><div class="line"></div><div class="line">    <span class="comment">// application logic</span></div><div class="line">    uint32_t loops = 100;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (--loops)</div><div class="line">    {</div><div class="line">        std::this_thread::sleep_for(std::chrono::seconds(1));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// unregister and destroy scene</span></div><div class="line">    scene-&gt;<a class="code" href="classramses_1_1Scene.html#a32cd8f7a7f1be370ba15b485489824f0">unpublish</a>();</div><div class="line">    <a class="code" href="namespaceramses.html">ramses</a>.destroy(*scene);</div><div class="line"></div><div class="line">    <span class="comment">// disconnect from RAMSES daemon</span></div><div class="line">    framework.disconnect();</div></div><!-- fragment --> <h2>Basic Geometry</h2>
<p>This code creates a simple geometry. </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line"></div><div class="line">    <span class="comment">// prepare triangle geometry: vertex position array and index array</span></div><div class="line">    <span class="keywordtype">float</span> vertexPositionsArray[] = { -1.f, 0.f, -1.f, 1.f, 0.f, -1.f, 0.f, 1.f, -1.f };</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classramses_1_1Vector3fArray.html">ramses::Vector3fArray</a>* vertexPositions = <a class="code" href="namespaceramses.html">ramses</a>.createConstVector3fArray(3, vertexPositionsArray);</div><div class="line"></div><div class="line">    <span class="comment">// create an appearance for red triangle</span></div><div class="line">    <a class="code" href="classramses_1_1EffectDescription.html">ramses::EffectDescription</a> effectDesc;</div><div class="line">    effectDesc.<a class="code" href="classramses_1_1EffectDescription.html#aa08514cddaf554eb165ebfd0ae20be45">setVertexShaderFromFile</a>(<span class="stringliteral">&quot;res/ramses-example-basic-geometry.vert&quot;</span>);</div><div class="line">    effectDesc.<a class="code" href="classramses_1_1EffectDescription.html#aeb8695b36a1d62720b26bc5e32ee3702">setFragmentShaderFromFile</a>(<span class="stringliteral">&quot;res/ramses-example-basic-geometry.frag&quot;</span>);</div><div class="line">    effectDesc.<a class="code" href="classramses_1_1EffectDescription.html#aa6441d0d110fd4fb04f9e5d2a471c4da">setUniformSemantic</a>(<span class="stringliteral">&quot;mvpMatrix&quot;</span>, <a class="code" href="namespaceramses.html#a62ffd4eb754f4139d86eec8b4529529fa72ccdf009a23222118b1c8ea7cd60703">ramses::EEffectUniformSemantic_ModelViewProjectionMatrix</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classramses_1_1Effect.html">ramses::Effect</a>* effect = <a class="code" href="namespaceramses.html">ramses</a>.createEffect(effectDesc, <a class="code" href="namespaceramses.html#aa4f32a02a4d27b0759cf54915b6ce602">ramses::ResourceCacheFlag_DoNotCache</a>, <span class="stringliteral">&quot;glsl shader&quot;</span>);</div><div class="line">    <a class="code" href="classramses_1_1Appearance.html">ramses::Appearance</a>* appearance = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a5980a75ccc0e21f175f6d75803fb9d2b">createAppearance</a>(*effect, <span class="stringliteral">&quot;triangle appearance&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// set vertex positions directly in geometry</span></div><div class="line">    <a class="code" href="classramses_1_1GeometryBinding.html">ramses::GeometryBinding</a>* geometry = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a45950bffee8db288152f030f8b95736b">createGeometryBinding</a>(*effect, <span class="stringliteral">&quot;triangle geometry&quot;</span>);</div><div class="line">    <a class="code" href="classramses_1_1AttributeInput.html">ramses::AttributeInput</a> positionsInput;</div><div class="line">    effect-&gt;<a class="code" href="classramses_1_1Effect.html#af6e6133c71f080b725e1a985518fc35f">findAttributeInput</a>(<span class="stringliteral">&quot;a_position&quot;</span>, positionsInput);</div><div class="line">    geometry-&gt;<a class="code" href="classramses_1_1GeometryBinding.html#aa5d2fbb568d5638a64e70ed19135a8e7">setInputBuffer</a>(positionsInput, *vertexPositions);</div><div class="line"></div><div class="line">    <span class="comment">// get input data of appearance and bind required data</span></div><div class="line">    <a class="code" href="classramses_1_1UniformInput.html">ramses::UniformInput</a> colorInput;</div><div class="line">    effect-&gt;<a class="code" href="classramses_1_1Effect.html#a991b1b19203b657810f0c5917e213ad7">findUniformInput</a>(<span class="stringliteral">&quot;color&quot;</span>, colorInput);</div><div class="line">    appearance-&gt;<a class="code" href="classramses_1_1Appearance.html#a5b29e6be97053f2a3aae5216806018f6">setInputValueVector4f</a>(colorInput, 1.0f, 0.0f, 0.0f, 1.0f);</div><div class="line"></div><div class="line">    <span class="comment">// create a mesh node to define the triangle with chosen appearance</span></div><div class="line">    <a class="code" href="classramses_1_1MeshNode.html">ramses::MeshNode</a>* meshNode = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a0b73e5ae2f197bf8e814eea743566a53">createMeshNode</a>(<span class="stringliteral">&quot;triangle mesh node&quot;</span>);</div><div class="line">    meshNode-&gt;<a class="code" href="classramses_1_1MeshNode.html#a03307af9bb4e533eca06fd119f635481">setAppearance</a>(*appearance);</div><div class="line">    meshNode-&gt;<a class="code" href="classramses_1_1MeshNode.html#ae7f99ac6ac11b6013f8aa6a37da0e4ac">setIndexCount</a>(3);</div><div class="line">    meshNode-&gt;<a class="code" href="classramses_1_1MeshNode.html#abf97e76c45b196bc3ee0eea5fac8032e">setGeometryBinding</a>(*geometry);</div><div class="line"></div><div class="line">    <span class="comment">// mesh needs to be added to a render group that belongs to a render pass with camera in order to be rendered</span></div><div class="line">    renderGroup-&gt;addMeshNode(*meshNode);</div></div><!-- fragment --> <h2>Basic Scene Graph</h2>
<p>This code creates a simple scene graph with multiple nodes. </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line"></div><div class="line">    <span class="comment">// create node as root</span></div><div class="line">    <a class="code" href="classramses_1_1Node.html">ramses::Node</a>* group = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a24c2b19e21adcf073882fa0b8fd818d8">createNode</a>(<span class="stringliteral">&quot;group of triangles&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// create grid of triangles</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> row = 0; row &lt; 2; ++row)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> column = 0; column &lt; 3; ++column)</div><div class="line">        {</div><div class="line">            <span class="comment">// create a mesh node to define the triangle with chosen appearance</span></div><div class="line">            <a class="code" href="classramses_1_1MeshNode.html">ramses::MeshNode</a>* meshNode = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a0b73e5ae2f197bf8e814eea743566a53">createMeshNode</a>(<span class="stringliteral">&quot;triangle mesh node&quot;</span>);</div><div class="line">            meshNode-&gt;<a class="code" href="classramses_1_1MeshNode.html#a03307af9bb4e533eca06fd119f635481">setAppearance</a>(*appearance);</div><div class="line">            meshNode-&gt;<a class="code" href="classramses_1_1MeshNode.html#abf97e76c45b196bc3ee0eea5fac8032e">setGeometryBinding</a>(*geometry);</div><div class="line">            meshNode-&gt;<a class="code" href="classramses_1_1Node.html#a8f8cb6996cd77f70f03ebc5a65fd37b4">setTranslation</a>(column * 0.2f, row * 0.2f, 0.0f);</div><div class="line">            meshNode-&gt;<a class="code" href="classramses_1_1Node.html#a323e05d9bccb97d0541c6ec3f730baf2">setParent</a>(*group);</div><div class="line">            <span class="comment">// mesh needs to be added to a render group that belongs to a render pass with camera in order to be rendered</span></div><div class="line">            renderGroup-&gt;addMeshNode(*meshNode);</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --> <h2>Basic Animation</h2>
<p>This code creates a simple animation of a color of an appearance. </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line"></div><div class="line">    <span class="comment">// create animation system, provide creation flag</span></div><div class="line">    <span class="comment">// EAnimationSystemFlags_LiveUpdates to get live updates of animated properties</span></div><div class="line">    <a class="code" href="classramses_1_1AnimationSystem.html">ramses::AnimationSystem</a>* animationSystem = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a6c8484b3946cee62613ed7819d84b3d0">createAnimationSystem</a>(<a class="code" href="namespaceramses.html#a5def0f60a48cd70bbc4ebbe5b4ea59a1ad5d4765c285461af8267645e7ef6965a">ramses::EAnimationSystemFlags_ClientSideProcessing</a>, <span class="stringliteral">&quot;animation system&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// create spline with animation keys</span></div><div class="line">    <a class="code" href="classramses_1_1SplineLinearFloat.html">ramses::SplineLinearFloat</a>* colorSpline = animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystem.html#a280d9fa1ed1b9667d9182a5c513b6b77">createSplineLinearFloat</a>(<span class="stringliteral">&quot;color spline&quot;</span>);</div><div class="line">    colorSpline-&gt;<a class="code" href="classramses_1_1SplineLinearFloat.html#a37a1793003b8fddc9e9210fa65e7b306">setKey</a>(0u, 0.f);</div><div class="line">    colorSpline-&gt;<a class="code" href="classramses_1_1SplineLinearFloat.html#a37a1793003b8fddc9e9210fa65e7b306">setKey</a>(5000u, 1.f);</div><div class="line">    colorSpline-&gt;<a class="code" href="classramses_1_1SplineLinearFloat.html#a37a1793003b8fddc9e9210fa65e7b306">setKey</a>(10000u, 0.f);</div><div class="line"></div><div class="line">    <span class="comment">// get handle to appearance input</span></div><div class="line">    <a class="code" href="classramses_1_1UniformInput.html">ramses::UniformInput</a> colorInput;</div><div class="line">    effect-&gt;<a class="code" href="classramses_1_1Effect.html#a991b1b19203b657810f0c5917e213ad7">findUniformInput</a>(<span class="stringliteral">&quot;color&quot;</span>, colorInput);</div><div class="line">    appearance-&gt;<a class="code" href="classramses_1_1Appearance.html#a5b29e6be97053f2a3aae5216806018f6">setInputValueVector4f</a>(colorInput, 1.f, 0.f, 0.f, 1.f);</div><div class="line"></div><div class="line">    <span class="comment">// create animated property for color input with single component animation (green color channel is referred to via Z component)</span></div><div class="line">    <a class="code" href="classramses_1_1AnimatedProperty.html">ramses::AnimatedProperty</a>* colorAnimProperty = animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystem.html#a4d2ad442cf7cc6e0e4435d0ba5cbc61e">createAnimatedProperty</a>(colorInput, *appearance, <a class="code" href="namespaceramses.html#a295c99b91730bfeaaba46d74a8943378a97d975d54ffcc75085ae5c9f058518ac">ramses::EAnimatedPropertyComponent_Y</a>);</div><div class="line"></div><div class="line">    <span class="comment">// create animation</span></div><div class="line">    <a class="code" href="classramses_1_1Animation.html">ramses::Animation</a>* animation = animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystem.html#a5ad1d1f9abc0d501f0158467d17f5582">createAnimation</a>(*colorAnimProperty, *colorSpline, <span class="stringliteral">&quot;color animation&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// create animation sequence and add animation</span></div><div class="line">    <a class="code" href="classramses_1_1AnimationSequence.html">ramses::AnimationSequence</a>* sequence = animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystem.html#a0979e50f1d6244067d15961c1e50a6b0">createAnimationSequence</a>();</div><div class="line">    sequence-&gt;<a class="code" href="classramses_1_1AnimationSequence.html#a4e263a25e023009d7305d15423f655b5">addAnimation</a>(*animation);</div><div class="line"></div><div class="line">    <span class="comment">// set animation properties (optional)</span></div><div class="line">    sequence-&gt;<a class="code" href="classramses_1_1AnimationSequence.html#abab20c79d89c06e577d1bf26751c24fd">setAnimationLooping</a>(*animation);</div><div class="line"></div><div class="line">    <span class="comment">// start sequence</span></div><div class="line">    sequence-&gt;<a class="code" href="classramses_1_1AnimationSequence.html#a6d670be16d593f7cd85d2e18560c739e">setPlaybackSpeed</a>(5.f);</div><div class="line">    sequence-&gt;<a class="code" href="classramses_1_1AnimationSequence.html#ae28d87d1fe6d544ef8e6d0ae40b067e9">startAt</a>(0u);</div><div class="line"></div><div class="line">    <span class="comment">// signal the scene it is in a state that can be rendered</span></div><div class="line">    scene-&gt;<a class="code" href="classramses_1_1Scene.html#ac12e7548df54a23bc10c1e5629c1aa88">flush</a>();</div><div class="line"></div><div class="line">    <span class="comment">// distribute the scene to RAMSES</span></div><div class="line">    scene-&gt;<a class="code" href="classramses_1_1Scene.html#a495b0efc631c28c15b818f5c765dbbba">publish</a>();</div><div class="line"></div><div class="line">    <span class="comment">// application logic</span></div><div class="line"></div><div class="line">    <span class="keywordtype">float</span> x;</div><div class="line">    <span class="keywordtype">float</span> y;</div><div class="line">    <span class="keywordtype">float</span> z;</div><div class="line">    <span class="keywordtype">float</span> w;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint64_t timeStamp = 0u; timeStamp &lt; 10000u; timeStamp += 20u)</div><div class="line">    {</div><div class="line">        animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystem.html#acb47a27af5f5a904f338cb2c053d4b06">setTime</a>(timeStamp);</div><div class="line"></div><div class="line">        <span class="comment">// print current value of animated property</span></div><div class="line">        appearance-&gt;<a class="code" href="classramses_1_1Appearance.html#ad286fb5d2df6660319592a9c7089355a">getInputValueVector4f</a>(colorInput, x, y, z, w);</div><div class="line">        printf(<span class="stringliteral">&quot;%f %f %f %f\n&quot;</span>, x, y, z, w);</div><div class="line"></div><div class="line">        <span class="comment">// signal the scene it is in a state that can be rendered</span></div><div class="line">        scene-&gt;<a class="code" href="classramses_1_1Scene.html#ac12e7548df54a23bc10c1e5629c1aa88">flush</a>();</div><div class="line"></div><div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(20));</div><div class="line">    }</div></div><!-- fragment --> <h2>Basic Realtime Animation</h2>
<p>This code creates a simple realtime animation sequence with three triangles. </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line"></div><div class="line">    <span class="comment">// create real time animation system, provide creation flag</span></div><div class="line">    <span class="comment">// EAnimationSystemFlags_ClientSideProcessing to get live updates of animated properties</span></div><div class="line">    <a class="code" href="classramses_1_1AnimationSystemRealTime.html">ramses::AnimationSystemRealTime</a>* animationSystem = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a908bdddeeb758d4f32aeab8a9917b86c">createRealTimeAnimationSystem</a>(<a class="code" href="namespaceramses.html#a5def0f60a48cd70bbc4ebbe5b4ea59a1ad5d4765c285461af8267645e7ef6965a">ramses::EAnimationSystemFlags_ClientSideProcessing</a>, <span class="stringliteral">&quot;animation system&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// create splines with animation keys</span></div><div class="line">    <a class="code" href="classramses_1_1SplineLinearFloat.html">ramses::SplineLinearFloat</a>* spline1 = animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystem.html#a280d9fa1ed1b9667d9182a5c513b6b77">createSplineLinearFloat</a>(<span class="stringliteral">&quot;spline1&quot;</span>);</div><div class="line">    spline1-&gt;<a class="code" href="classramses_1_1SplineLinearFloat.html#a37a1793003b8fddc9e9210fa65e7b306">setKey</a>(0u, 0.f);</div><div class="line">    spline1-&gt;<a class="code" href="classramses_1_1SplineLinearFloat.html#a37a1793003b8fddc9e9210fa65e7b306">setKey</a>(5000u, -1.f);</div><div class="line">    spline1-&gt;<a class="code" href="classramses_1_1SplineLinearFloat.html#a37a1793003b8fddc9e9210fa65e7b306">setKey</a>(10000u, 0.f);</div><div class="line">    <a class="code" href="classramses_1_1SplineLinearFloat.html">ramses::SplineLinearFloat</a>* spline2 = animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystem.html#a280d9fa1ed1b9667d9182a5c513b6b77">createSplineLinearFloat</a>(<span class="stringliteral">&quot;spline2&quot;</span>);</div><div class="line">    spline2-&gt;<a class="code" href="classramses_1_1SplineLinearFloat.html#a37a1793003b8fddc9e9210fa65e7b306">setKey</a>(0u, 0.f);</div><div class="line">    spline2-&gt;<a class="code" href="classramses_1_1SplineLinearFloat.html#a37a1793003b8fddc9e9210fa65e7b306">setKey</a>(5000u, 1.f);</div><div class="line">    spline2-&gt;<a class="code" href="classramses_1_1SplineLinearFloat.html#a37a1793003b8fddc9e9210fa65e7b306">setKey</a>(10000u, 0.f);</div><div class="line"></div><div class="line">    <span class="comment">// create animated property for each translation node with single component animation</span></div><div class="line">    <a class="code" href="classramses_1_1AnimatedProperty.html">ramses::AnimatedProperty</a>* animProperty1 = animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystem.html#a4d2ad442cf7cc6e0e4435d0ba5cbc61e">createAnimatedProperty</a>(*meshNode1, <a class="code" href="namespaceramses.html#a4c834e5dd2cf8179a34a50f6da43d3b0adc09359d9063ebfa556e57b8b898d2fc">ramses::EAnimatedProperty_Translation</a>, <a class="code" href="namespaceramses.html#a295c99b91730bfeaaba46d74a8943378ae425f9f2bb1718db50b68d9104bbddbc">ramses::EAnimatedPropertyComponent_X</a>);</div><div class="line">    <a class="code" href="classramses_1_1AnimatedProperty.html">ramses::AnimatedProperty</a>* animProperty2 = animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystem.html#a4d2ad442cf7cc6e0e4435d0ba5cbc61e">createAnimatedProperty</a>(*meshNode2, <a class="code" href="namespaceramses.html#a4c834e5dd2cf8179a34a50f6da43d3b0adc09359d9063ebfa556e57b8b898d2fc">ramses::EAnimatedProperty_Translation</a>, <a class="code" href="namespaceramses.html#a295c99b91730bfeaaba46d74a8943378ae425f9f2bb1718db50b68d9104bbddbc">ramses::EAnimatedPropertyComponent_X</a>);</div><div class="line">    <a class="code" href="classramses_1_1AnimatedProperty.html">ramses::AnimatedProperty</a>* animProperty3 = animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystem.html#a4d2ad442cf7cc6e0e4435d0ba5cbc61e">createAnimatedProperty</a>(*meshNode3, <a class="code" href="namespaceramses.html#a4c834e5dd2cf8179a34a50f6da43d3b0adc09359d9063ebfa556e57b8b898d2fc">ramses::EAnimatedProperty_Translation</a>, <a class="code" href="namespaceramses.html#a295c99b91730bfeaaba46d74a8943378a97d975d54ffcc75085ae5c9f058518ac">ramses::EAnimatedPropertyComponent_Y</a>);</div><div class="line"></div><div class="line">    <span class="comment">// create three animations</span></div><div class="line">    <a class="code" href="classramses_1_1Animation.html">ramses::Animation</a>* animation1 = animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystem.html#a5ad1d1f9abc0d501f0158467d17f5582">createAnimation</a>(*animProperty1, *spline1, <span class="stringliteral">&quot;animation1&quot;</span>);</div><div class="line">    <a class="code" href="classramses_1_1Animation.html">ramses::Animation</a>* animation2 = animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystem.html#a5ad1d1f9abc0d501f0158467d17f5582">createAnimation</a>(*animProperty2, *spline2, <span class="stringliteral">&quot;animation2&quot;</span>);</div><div class="line">    <a class="code" href="classramses_1_1Animation.html">ramses::Animation</a>* animation3 = animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystem.html#a5ad1d1f9abc0d501f0158467d17f5582">createAnimation</a>(*animProperty3, *spline1, <span class="stringliteral">&quot;animation3&quot;</span>); <span class="comment">// we can reuse spline1 for animating Y component of the third translation node</span></div><div class="line"></div><div class="line">    <span class="comment">// create animation sequence</span></div><div class="line">    <a class="code" href="classramses_1_1AnimationSequence.html">ramses::AnimationSequence</a>* animSequence = animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystem.html#a0979e50f1d6244067d15961c1e50a6b0">createAnimationSequence</a>();</div><div class="line"></div><div class="line">    <span class="comment">// add animations to a sequence</span></div><div class="line">    animSequence-&gt;<a class="code" href="classramses_1_1AnimationSequence.html#a4e263a25e023009d7305d15423f655b5">addAnimation</a>(*animation1);</div><div class="line">    animSequence-&gt;<a class="code" href="classramses_1_1AnimationSequence.html#a4e263a25e023009d7305d15423f655b5">addAnimation</a>(*animation2);</div><div class="line">    animSequence-&gt;<a class="code" href="classramses_1_1AnimationSequence.html#a4e263a25e023009d7305d15423f655b5">addAnimation</a>(*animation3);</div><div class="line"></div><div class="line">    <span class="comment">// set animation properties (optional)</span></div><div class="line">    animSequence-&gt;<a class="code" href="classramses_1_1AnimationSequence.html#abab20c79d89c06e577d1bf26751c24fd">setAnimationLooping</a>(*animation1);</div><div class="line">    animSequence-&gt;<a class="code" href="classramses_1_1AnimationSequence.html#abab20c79d89c06e577d1bf26751c24fd">setAnimationLooping</a>(*animation2);</div><div class="line">    animSequence-&gt;<a class="code" href="classramses_1_1AnimationSequence.html#abab20c79d89c06e577d1bf26751c24fd">setAnimationLooping</a>(*animation3);</div><div class="line"></div><div class="line">    <span class="comment">// set sequence playback speed</span></div><div class="line">    animSequence-&gt;<a class="code" href="classramses_1_1AnimationSequence.html#a6d670be16d593f7cd85d2e18560c739e">setPlaybackSpeed</a>(5.f);</div><div class="line"></div><div class="line">    <span class="comment">// start animation sequence</span></div><div class="line">    <span class="comment">// we use real time animation system, therefore we should provide system time</span></div><div class="line">    <span class="comment">// because renderer will be using system time to update its animation system every frame</span></div><div class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::now();</div><div class="line">    animSequence-&gt;<a class="code" href="classramses_1_1AnimationSequence.html#ae28d87d1fe6d544ef8e6d0ae40b067e9">startAt</a>(std::chrono::time_point_cast&lt;std::chrono::milliseconds&gt;(now).time_since_epoch().count());</div><div class="line"></div><div class="line">    <span class="comment">// signal the scene it is in a state that can be rendered</span></div><div class="line">    scene-&gt;<a class="code" href="classramses_1_1Scene.html#ac12e7548df54a23bc10c1e5629c1aa88">flush</a>();</div><div class="line"></div><div class="line">    <span class="comment">// distribute the scene to RAMSES</span></div><div class="line">    scene-&gt;<a class="code" href="classramses_1_1Scene.html#a495b0efc631c28c15b818f5c765dbbba">publish</a>();</div><div class="line"></div><div class="line">    <span class="comment">// no application logic is needed here</span></div><div class="line">    <span class="comment">// real time animation system is updated automatically on renderer every frame using system time</span></div><div class="line"></div><div class="line">    <span class="keywordtype">float</span> x;</div><div class="line">    <span class="keywordtype">float</span> y;</div><div class="line">    <span class="keywordtype">float</span> z;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii &lt; 500; ++ii)</div><div class="line">    {</div><div class="line">        <span class="comment">// with RealTimeAnimationSystem, updateLocalTime() has to be called</span></div><div class="line">        <span class="comment">// to get up-to-date animated values</span></div><div class="line">        animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystemRealTime.html#a1fd7204f0f05a523d56ffec11be04417">updateLocalTime</a>();</div><div class="line"></div><div class="line">        <span class="comment">// print current value of animated property</span></div><div class="line">        meshNode1-&gt;getTranslation(x, y, z);</div><div class="line"></div><div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(10));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// however local client animation system should be updated before any change is made</span></div><div class="line">    animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystemRealTime.html#a1fd7204f0f05a523d56ffec11be04417">updateLocalTime</a>();</div><div class="line">    animSequence-&gt;<a class="code" href="classramses_1_1AnimationSequence.html#a6d670be16d593f7cd85d2e18560c739e">setPlaybackSpeed</a>(10.f);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii &lt; 500; ++ii)</div><div class="line">    {</div><div class="line">        <span class="comment">// with RealTimeAnimationSystem, updateLocalTime() has to be called</span></div><div class="line">        <span class="comment">// to get up-to-date animated values</span></div><div class="line">        animationSystem-&gt;<a class="code" href="classramses_1_1AnimationSystemRealTime.html#a1fd7204f0f05a523d56ffec11be04417">updateLocalTime</a>();</div><div class="line"></div><div class="line">        <span class="comment">// print current value of animated property</span></div><div class="line">        meshNode1-&gt;getTranslation(x, y, z);</div><div class="line"></div><div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(10));</div><div class="line">    }</div></div><!-- fragment --> <h2>Basic Blending</h2>
<p>This code creates a simple scene consisting of three triangles with alpha blending. </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line"></div><div class="line">    <span class="comment">// set blending states for alpha blending</span></div><div class="line">    appearanceRed-&gt;setBlendingFactors(<a class="code" href="namespaceramses.html#ad92db747f446d34174fe02bc106db60aad4ea42d780d57674c049cded1e23b870">ramses::EBlendFactor_SrcAlpha</a>, <a class="code" href="namespaceramses.html#ad92db747f446d34174fe02bc106db60aa38ca3aa38628208af2024f75d781ed08">ramses::EBlendFactor_OneMinusSrcAlpha</a>, <a class="code" href="namespaceramses.html#ad92db747f446d34174fe02bc106db60aa4ac74913fc4c6a9ed07723e941c60341">ramses::EBlendFactor_One</a>, <a class="code" href="namespaceramses.html#ad92db747f446d34174fe02bc106db60aa4ac74913fc4c6a9ed07723e941c60341">ramses::EBlendFactor_One</a>);</div><div class="line">    appearanceRed-&gt;setBlendingOperations(<a class="code" href="namespaceramses.html#ae003c64dd1ee017a9c7afda5070c5277ab073260c68c58d39df3df7cf524bab5e">ramses::EBlendOperation_Add</a>, <a class="code" href="namespaceramses.html#ae003c64dd1ee017a9c7afda5070c5277ab073260c68c58d39df3df7cf524bab5e">ramses::EBlendOperation_Add</a>);</div><div class="line">    appearanceGreen-&gt;setBlendingFactors(<a class="code" href="namespaceramses.html#ad92db747f446d34174fe02bc106db60aad4ea42d780d57674c049cded1e23b870">ramses::EBlendFactor_SrcAlpha</a>, <a class="code" href="namespaceramses.html#ad92db747f446d34174fe02bc106db60aa38ca3aa38628208af2024f75d781ed08">ramses::EBlendFactor_OneMinusSrcAlpha</a>, <a class="code" href="namespaceramses.html#ad92db747f446d34174fe02bc106db60aa4ac74913fc4c6a9ed07723e941c60341">ramses::EBlendFactor_One</a>, <a class="code" href="namespaceramses.html#ad92db747f446d34174fe02bc106db60aa4ac74913fc4c6a9ed07723e941c60341">ramses::EBlendFactor_One</a>);</div><div class="line">    appearanceGreen-&gt;setBlendingOperations(<a class="code" href="namespaceramses.html#ae003c64dd1ee017a9c7afda5070c5277ab073260c68c58d39df3df7cf524bab5e">ramses::EBlendOperation_Add</a>, <a class="code" href="namespaceramses.html#ae003c64dd1ee017a9c7afda5070c5277ab073260c68c58d39df3df7cf524bab5e">ramses::EBlendOperation_Add</a>);</div><div class="line">    appearanceBlue-&gt;setBlendingFactors(<a class="code" href="namespaceramses.html#ad92db747f446d34174fe02bc106db60aad4ea42d780d57674c049cded1e23b870">ramses::EBlendFactor_SrcAlpha</a>, <a class="code" href="namespaceramses.html#ad92db747f446d34174fe02bc106db60aa38ca3aa38628208af2024f75d781ed08">ramses::EBlendFactor_OneMinusSrcAlpha</a>, <a class="code" href="namespaceramses.html#ad92db747f446d34174fe02bc106db60aa4ac74913fc4c6a9ed07723e941c60341">ramses::EBlendFactor_One</a>, <a class="code" href="namespaceramses.html#ad92db747f446d34174fe02bc106db60aa4ac74913fc4c6a9ed07723e941c60341">ramses::EBlendFactor_One</a>);</div><div class="line">    appearanceBlue-&gt;setBlendingOperations(<a class="code" href="namespaceramses.html#ae003c64dd1ee017a9c7afda5070c5277ab073260c68c58d39df3df7cf524bab5e">ramses::EBlendOperation_Add</a>, <a class="code" href="namespaceramses.html#ae003c64dd1ee017a9c7afda5070c5277ab073260c68c58d39df3df7cf524bab5e">ramses::EBlendOperation_Add</a>);</div><div class="line"></div><div class="line">    <span class="comment">// set appearances to mesh nodes</span></div><div class="line">    meshNodeRed-&gt;setAppearance(*appearanceRed);</div><div class="line">    meshNodeGreen-&gt;setAppearance(*appearanceGreen);</div><div class="line">    meshNodeBlue-&gt;setAppearance(*appearanceBlue);</div><div class="line"></div><div class="line">    <span class="comment">// set same geometry to all mesh nodes</span></div><div class="line">    meshNodeRed-&gt;setGeometryBinding(*geometry);</div><div class="line">    meshNodeGreen-&gt;setGeometryBinding(*geometry);</div><div class="line">    meshNodeBlue-&gt;setGeometryBinding(*geometry);</div><div class="line"></div><div class="line">    <span class="comment">// mesh needs to be added to a render group that belongs to a render pass with camera in order to be rendered</span></div><div class="line">    <span class="comment">// set render order so that triangles are rendered back to front</span></div><div class="line">    renderGroup-&gt;addMeshNode(*meshNodeRed, 0);</div><div class="line">    renderGroup-&gt;addMeshNode(*meshNodeGreen, 1);</div><div class="line">    renderGroup-&gt;addMeshNode(*meshNodeBlue, 2);</div></div><!-- fragment --> <h2>Basic GLSL Import</h2>
<p>This code creates an appearance by importing GLSL ES 2.0 shader code files. The appearance is then used to render a simple geometry. </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line"></div><div class="line">    <span class="comment">// create an appearance for red triangle</span></div><div class="line">    <a class="code" href="classramses_1_1EffectDescription.html">ramses::EffectDescription</a> effectDesc;</div><div class="line">    effectDesc.<a class="code" href="classramses_1_1EffectDescription.html#aa08514cddaf554eb165ebfd0ae20be45">setVertexShaderFromFile</a>(<span class="stringliteral">&quot;res/ramses-example-basic-effect-from-glsl.vert&quot;</span>);</div><div class="line">    effectDesc.<a class="code" href="classramses_1_1EffectDescription.html#aeb8695b36a1d62720b26bc5e32ee3702">setFragmentShaderFromFile</a>(<span class="stringliteral">&quot;res/ramses-example-basic-effect-from-glsl.frag&quot;</span>);</div><div class="line">    effectDesc.<a class="code" href="classramses_1_1EffectDescription.html#aa6441d0d110fd4fb04f9e5d2a471c4da">setUniformSemantic</a>(<span class="stringliteral">&quot;mvpMatrix&quot;</span>, <a class="code" href="namespaceramses.html#a62ffd4eb754f4139d86eec8b4529529fa72ccdf009a23222118b1c8ea7cd60703">ramses::EEffectUniformSemantic_ModelViewProjectionMatrix</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classramses_1_1Effect.html">ramses::Effect</a>* effect = <a class="code" href="namespaceramses.html">ramses</a>.createEffect(effectDesc, <a class="code" href="namespaceramses.html#aa4f32a02a4d27b0759cf54915b6ce602">ramses::ResourceCacheFlag_DoNotCache</a>, <span class="stringliteral">&quot;glsl shader&quot;</span>);</div><div class="line">    <a class="code" href="classramses_1_1Appearance.html">ramses::Appearance</a>* appearance = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a5980a75ccc0e21f175f6d75803fb9d2b">createAppearance</a>(*effect, <span class="stringliteral">&quot;triangle appearance&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// set vertex positions directly in geometry</span></div><div class="line">    <a class="code" href="classramses_1_1GeometryBinding.html">ramses::GeometryBinding</a>* geometry = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a45950bffee8db288152f030f8b95736b">createGeometryBinding</a>(*effect, <span class="stringliteral">&quot;triangle geometry&quot;</span>);</div><div class="line">    geometry-&gt;<a class="code" href="classramses_1_1GeometryBinding.html#aaa304ccc5bbcb658cec3f6fa936426ef">setIndices</a>(*indices);</div><div class="line">    <a class="code" href="classramses_1_1AttributeInput.html">ramses::AttributeInput</a> positionsInput;</div><div class="line">    effect-&gt;<a class="code" href="classramses_1_1Effect.html#af6e6133c71f080b725e1a985518fc35f">findAttributeInput</a>(<span class="stringliteral">&quot;a_position&quot;</span>, positionsInput);</div><div class="line">    geometry-&gt;<a class="code" href="classramses_1_1GeometryBinding.html#aa5d2fbb568d5638a64e70ed19135a8e7">setInputBuffer</a>(positionsInput, *vertexPositions);</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1UniformInput.html">ramses::UniformInput</a> scaleAndShearInput;</div><div class="line">    effect-&gt;<a class="code" href="classramses_1_1Effect.html#a991b1b19203b657810f0c5917e213ad7">findUniformInput</a>(<span class="stringliteral">&quot;u_transformations&quot;</span>, scaleAndShearInput);</div><div class="line"></div><div class="line">    <span class="keywordtype">float</span> scaleAndShearArrayData[] = { 0.3f, 0.6f, 0.0f, 0.0f, 0.3f, 0.6f, 0.0f, 0.0f };</div><div class="line">    appearance-&gt;<a class="code" href="classramses_1_1Appearance.html#a5b29e6be97053f2a3aae5216806018f6">setInputValueVector4f</a>(scaleAndShearInput, 2, scaleAndShearArrayData);</div><div class="line"></div><div class="line">    <span class="comment">// create a mesh node to define the triangle with chosen appearance</span></div><div class="line">    <a class="code" href="classramses_1_1MeshNode.html">ramses::MeshNode</a>* meshNode = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a0b73e5ae2f197bf8e814eea743566a53">createMeshNode</a>(<span class="stringliteral">&quot;triangle mesh node&quot;</span>);</div><div class="line">    meshNode-&gt;<a class="code" href="classramses_1_1MeshNode.html#a03307af9bb4e533eca06fd119f635481">setAppearance</a>(*appearance);</div><div class="line">    meshNode-&gt;<a class="code" href="classramses_1_1MeshNode.html#abf97e76c45b196bc3ee0eea5fac8032e">setGeometryBinding</a>(*geometry);</div><div class="line">    <span class="comment">// mesh needs to be added to a render group that belongs to a render pass with camera in order to be rendered</span></div><div class="line">    renderGroup-&gt;addMeshNode(*meshNode);</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1UniformInput.html">ramses::UniformInput</a> colorInput;</div><div class="line">    effect-&gt;<a class="code" href="classramses_1_1Effect.html#a991b1b19203b657810f0c5917e213ad7">findUniformInput</a>(<span class="stringliteral">&quot;color&quot;</span>, colorInput);</div><div class="line">    appearance-&gt;<a class="code" href="classramses_1_1Appearance.html#a5b29e6be97053f2a3aae5216806018f6">setInputValueVector4f</a>(colorInput, 0.1f, 0.5f, 0.2f, 1.0);</div><div class="line"></div></div><!-- fragment --> <h2>Basic Render Groups Handling</h2>
<p>This code shows the usage of (nested) render groups. Render groups are containing renderables which are rendered within the render pass the render group is added to. The renderables inside one render group have an order in which they are rendered. A render group can also contain other nested render groups with their renderables. The example shows a render group containing two elements, a mesh and a nested render group with two further meshes. </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line"></div><div class="line">    <span class="comment">// create a scene using explicit render passes</span></div><div class="line">    <a class="code" href="classramses_1_1Scene.html">ramses::Scene</a>* scene = <a class="code" href="namespaceramses.html">ramses</a>.createScene(<a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::sceneId_t</a>(123u), <a class="code" href="classramses_1_1SceneConfig.html">ramses::SceneConfig</a>(), <span class="stringliteral">&quot;basic renderpasses scene&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// every render pass needs a camera to define rendering parameters</span></div><div class="line">    <span class="comment">// create camera with perspective projection</span></div><div class="line">    <a class="code" href="classramses_1_1PerspectiveCamera.html">ramses::PerspectiveCamera</a>* camera = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a861cc4650a056daada6f76b5d0c8ab7d">createPerspectiveCamera</a>(<span class="stringliteral">&quot;perspective camera of renderpass&quot;</span>);</div><div class="line">    camera-&gt;<a class="code" href="classramses_1_1Node.html#a8f8cb6996cd77f70f03ebc5a65fd37b4">setTranslation</a>(0.0f, 0.0f, 5.0f);</div><div class="line">    camera-&gt;<a class="code" href="classramses_1_1PerspectiveCamera.html#aea24c939692f0a046b473cf6d0e16267">setFrustum</a>(45.f, 640.f / 480.f, 1.f, 100.f);</div><div class="line">    <span class="comment">// use left side of the viewport</span></div><div class="line">    camera-&gt;<a class="code" href="classramses_1_1LocalCamera.html#aacf595ebc6dd8026ff0da01cb6af9be5">setViewport</a>(0u, 0u, 640u, 480u);</div><div class="line"></div><div class="line">    <span class="comment">// create render pass</span></div><div class="line">    <a class="code" href="classramses_1_1RenderPass.html">ramses::RenderPass</a>* renderPass = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a5655e6484fda44cc3e9cccab2a939616">createRenderPass</a>(<span class="stringliteral">&quot;renderpass&quot;</span>);</div><div class="line">    renderPass-&gt;<a class="code" href="classramses_1_1RenderPass.html#a0bb72789d6253e0e4a6706a5268a09eb">setClearFlags</a>(<a class="code" href="namespaceramses.html#a5a24b250587d10d14d00389a8a74096aaaa3bf781f879d8c7bf83045abc831719">ramses::EClearFlags_None</a>);</div><div class="line"></div><div class="line">    <span class="comment">// set valid camera for the pass</span></div><div class="line">    renderPass-&gt;<a class="code" href="classramses_1_1RenderPass.html#a0a8ac513cd7bb87d08a8e96d1e678b6a">setCamera</a>(*camera);</div><div class="line"></div><div class="line">    <span class="comment">// create render group and add it to render pass</span></div><div class="line">    <a class="code" href="classramses_1_1RenderGroup.html">ramses::RenderGroup</a>* renderGroup = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a7d3e0b1a87cb6a18ac64cb227f36f5e8">createRenderGroup</a>(<span class="stringliteral">&quot;rendergroup&quot;</span>);</div><div class="line">    renderPass-&gt;<a class="code" href="classramses_1_1RenderPass.html#a470ac8c21ca2b3157d9f006cbba946ac">addRenderGroup</a>(*renderGroup);</div><div class="line"></div><div class="line">    <span class="comment">// create another render group and add it to first one as nested render group with render order &#39;3&#39;</span></div><div class="line">    <a class="code" href="classramses_1_1RenderGroup.html">ramses::RenderGroup</a>* nestedRenderGroup= scene-&gt;<a class="code" href="classramses_1_1Scene.html#a7d3e0b1a87cb6a18ac64cb227f36f5e8">createRenderGroup</a>(<span class="stringliteral">&quot;nested rendergroup&quot;</span>);</div><div class="line">    renderGroup-&gt;<a class="code" href="classramses_1_1RenderGroup.html#aa13d515973bd1dd65e05933a18f15cd3">addRenderGroup</a>(*nestedRenderGroup, 3);</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1Appearance.html">ramses::Appearance</a>* appearanceA = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a5980a75ccc0e21f175f6d75803fb9d2b">createAppearance</a>(*effectTex, <span class="stringliteral">&quot;triangle appearance&quot;</span>);</div><div class="line">    <a class="code" href="classramses_1_1Appearance.html">ramses::Appearance</a>* appearanceB = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a5980a75ccc0e21f175f6d75803fb9d2b">createAppearance</a>(*effectTex, <span class="stringliteral">&quot;triangle appearance&quot;</span>);</div><div class="line">    <a class="code" href="classramses_1_1Appearance.html">ramses::Appearance</a>* appearanceC = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a5980a75ccc0e21f175f6d75803fb9d2b">createAppearance</a>(*effectTex, <span class="stringliteral">&quot;triangle appearance&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// set vertex positions directly in geometry</span></div><div class="line">    <a class="code" href="classramses_1_1GeometryBinding.html">ramses::GeometryBinding</a>* geometry = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a45950bffee8db288152f030f8b95736b">createGeometryBinding</a>(*effectTex, <span class="stringliteral">&quot;triangle geometry&quot;</span>);</div><div class="line">    geometry-&gt;<a class="code" href="classramses_1_1GeometryBinding.html#aaa304ccc5bbcb658cec3f6fa936426ef">setIndices</a>(*indices);</div><div class="line">    <a class="code" href="classramses_1_1AttributeInput.html">ramses::AttributeInput</a> positionsInput;</div><div class="line">    effectTex-&gt;findAttributeInput(<span class="stringliteral">&quot;a_position&quot;</span>, positionsInput);</div><div class="line">    geometry-&gt;<a class="code" href="classramses_1_1GeometryBinding.html#aa5d2fbb568d5638a64e70ed19135a8e7">setInputBuffer</a>(positionsInput, *vertexPositions);</div><div class="line"></div><div class="line">    <span class="comment">// use three appearances, each with a different color for distinguishing the meshes</span></div><div class="line">    <a class="code" href="classramses_1_1UniformInput.html">ramses::UniformInput</a> color;</div><div class="line">    effectTex-&gt;findUniformInput(<span class="stringliteral">&quot;color&quot;</span>, color);</div><div class="line">    appearanceA-&gt;<a class="code" href="classramses_1_1Appearance.html#a5b29e6be97053f2a3aae5216806018f6">setInputValueVector4f</a>(color, 1.0f,0.0f,0.0f,1.0f);</div><div class="line">    appearanceB-&gt;<a class="code" href="classramses_1_1Appearance.html#a5b29e6be97053f2a3aae5216806018f6">setInputValueVector4f</a>(color, 0.0f,1.0f,0.0f,1.0f);</div><div class="line">    appearanceC-&gt;<a class="code" href="classramses_1_1Appearance.html#a5b29e6be97053f2a3aae5216806018f6">setInputValueVector4f</a>(color, 0.0f,0.0f,1.0f,1.0f);</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1MeshNode.html">ramses::MeshNode</a>* meshNodeA = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a0b73e5ae2f197bf8e814eea743566a53">createMeshNode</a>(<span class="stringliteral">&quot;red triangle mesh node&quot;</span>);</div><div class="line">    meshNodeA-&gt;<a class="code" href="classramses_1_1MeshNode.html#a03307af9bb4e533eca06fd119f635481">setAppearance</a>(*appearanceA);</div><div class="line">    meshNodeA-&gt;<a class="code" href="classramses_1_1MeshNode.html#abf97e76c45b196bc3ee0eea5fac8032e">setGeometryBinding</a>(*geometry);</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1MeshNode.html">ramses::MeshNode</a>* meshNodeB = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a0b73e5ae2f197bf8e814eea743566a53">createMeshNode</a>(<span class="stringliteral">&quot;green triangle mesh node&quot;</span>);</div><div class="line">    meshNodeB-&gt;<a class="code" href="classramses_1_1MeshNode.html#a03307af9bb4e533eca06fd119f635481">setAppearance</a>(*appearanceB);</div><div class="line">    meshNodeB-&gt;<a class="code" href="classramses_1_1MeshNode.html#abf97e76c45b196bc3ee0eea5fac8032e">setGeometryBinding</a>(*geometry);</div><div class="line">    meshNodeB-&gt;<a class="code" href="classramses_1_1Node.html#a8f8cb6996cd77f70f03ebc5a65fd37b4">setTranslation</a>(0.5f, 0.5f, 0.0f);</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1MeshNode.html">ramses::MeshNode</a>* meshNodeC = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a0b73e5ae2f197bf8e814eea743566a53">createMeshNode</a>(<span class="stringliteral">&quot;blue triangle mesh node&quot;</span>);</div><div class="line">    meshNodeC-&gt;<a class="code" href="classramses_1_1MeshNode.html#a03307af9bb4e533eca06fd119f635481">setAppearance</a>(*appearanceC);</div><div class="line">    meshNodeC-&gt;<a class="code" href="classramses_1_1MeshNode.html#abf97e76c45b196bc3ee0eea5fac8032e">setGeometryBinding</a>(*geometry);</div><div class="line">    meshNodeC-&gt;<a class="code" href="classramses_1_1Node.html#a8f8cb6996cd77f70f03ebc5a65fd37b4">setTranslation</a>(0.75f, -0.25f, 0.0f);</div><div class="line"></div><div class="line">    <span class="comment">// Add meshA with render order &#39;1&#39; to the render group where already the nested render group with render order &#39;3&#39; was added.</span></div><div class="line">    <span class="comment">// So meshA is rendered before every other element of the nested render group.</span></div><div class="line">    renderGroup-&gt;<a class="code" href="classramses_1_1RenderGroup.html#a78df5ac3c86bb456a5e7a62d76a60b12">addMeshNode</a>(*meshNodeA, 1);</div><div class="line"></div><div class="line">    <span class="comment">// Add meshB and meshC to the nested render group with render order &#39;2&#39; and &#39;1&#39;.</span></div><div class="line">    <span class="comment">// This order is only relevant inside the nested render group. So C is rendered before B but both are rendered after A.</span></div><div class="line">    nestedRenderGroup-&gt;<a class="code" href="classramses_1_1RenderGroup.html#a78df5ac3c86bb456a5e7a62d76a60b12">addMeshNode</a>(*meshNodeB, 2);</div><div class="line">    nestedRenderGroup-&gt;<a class="code" href="classramses_1_1RenderGroup.html#a78df5ac3c86bb456a5e7a62d76a60b12">addMeshNode</a>(*meshNodeC, 1);</div><div class="line"></div></div><!-- fragment --> <h2>Render Pass and Camera Setup</h2>
<p>This code shows the usage of renderpasses and cameras. Each renderpass needs to have a valid camera assigned. The example creates two renderpasses, each with a camera using different projection and viewport parameters. In order for a mesh to be rendered it must be added to a renderpass. </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line"></div><div class="line">    <span class="comment">// create a scene using explicit render passes</span></div><div class="line">    <a class="code" href="classramses_1_1Scene.html">ramses::Scene</a>* scene = <a class="code" href="namespaceramses.html">ramses</a>.createScene(<a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::sceneId_t</a>(123u), <a class="code" href="classramses_1_1SceneConfig.html">ramses::SceneConfig</a>(), <span class="stringliteral">&quot;basic renderpasses scene&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// every render pass needs a camera to define rendering parameters</span></div><div class="line">    <span class="comment">// create camera with perspective projection</span></div><div class="line">    <a class="code" href="classramses_1_1Node.html">ramses::Node</a>* cameraTranslate = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a24c2b19e21adcf073882fa0b8fd818d8">createNode</a>();</div><div class="line">    cameraTranslate-&gt;<a class="code" href="classramses_1_1Node.html#a8f8cb6996cd77f70f03ebc5a65fd37b4">setTranslation</a>(0.0f, 0.0f, 5.0f);</div><div class="line">    <a class="code" href="classramses_1_1PerspectiveCamera.html">ramses::PerspectiveCamera</a>* cameraA = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a861cc4650a056daada6f76b5d0c8ab7d">createPerspectiveCamera</a>(<span class="stringliteral">&quot;perspective camera of renderpass A&quot;</span>);</div><div class="line">    cameraA-&gt;<a class="code" href="classramses_1_1Node.html#a323e05d9bccb97d0541c6ec3f730baf2">setParent</a>(*cameraTranslate);</div><div class="line">    cameraA-&gt;<a class="code" href="classramses_1_1PerspectiveCamera.html#aea24c939692f0a046b473cf6d0e16267">setFrustum</a>(45.f, 640.f / 480.f, 0.1f, 100.f);</div><div class="line">    <span class="comment">// use left side of the viewport</span></div><div class="line">    cameraA-&gt;<a class="code" href="classramses_1_1LocalCamera.html#aacf595ebc6dd8026ff0da01cb6af9be5">setViewport</a>(0u, 0u, 640u, 480u);</div><div class="line"></div><div class="line">    <span class="comment">// create camera with orthographic projection</span></div><div class="line">    <a class="code" href="classramses_1_1OrthographicCamera.html">ramses::OrthographicCamera</a>* cameraB = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a019a4b6ddb6c323256b0106995256466">createOrthographicCamera</a>(<span class="stringliteral">&quot;ortho camera of renderpass B&quot;</span>);</div><div class="line">    cameraB-&gt;<a class="code" href="classramses_1_1Node.html#a323e05d9bccb97d0541c6ec3f730baf2">setParent</a>(*cameraTranslate);</div><div class="line">    cameraB-&gt;<a class="code" href="classramses_1_1LocalCamera.html#a2ad45b979f1aa239ca30bfa53f379d52">setFrustum</a>(-2.f, 2.f, -2.f, 2.f, 0.1f, 100.f);</div><div class="line">    <span class="comment">// use right side of the viewport</span></div><div class="line">    cameraB-&gt;<a class="code" href="classramses_1_1LocalCamera.html#aacf595ebc6dd8026ff0da01cb6af9be5">setViewport</a>(640u, 0u, 640u, 480u);</div><div class="line"></div><div class="line">    <span class="comment">// create two renderpasses</span></div><div class="line">    <a class="code" href="classramses_1_1RenderPass.html">ramses::RenderPass</a>* renderPassA = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a5655e6484fda44cc3e9cccab2a939616">createRenderPass</a>(<span class="stringliteral">&quot;renderpass A&quot;</span>);</div><div class="line">    <a class="code" href="classramses_1_1RenderPass.html">ramses::RenderPass</a>* renderPassB = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a5655e6484fda44cc3e9cccab2a939616">createRenderPass</a>(<span class="stringliteral">&quot;renderpass B&quot;</span>);</div><div class="line">    renderPassA-&gt;<a class="code" href="classramses_1_1RenderPass.html#a0bb72789d6253e0e4a6706a5268a09eb">setClearFlags</a>(<a class="code" href="namespaceramses.html#a5a24b250587d10d14d00389a8a74096aaaa3bf781f879d8c7bf83045abc831719">ramses::EClearFlags_None</a>);</div><div class="line">    renderPassB-&gt;<a class="code" href="classramses_1_1RenderPass.html#a0bb72789d6253e0e4a6706a5268a09eb">setClearFlags</a>(<a class="code" href="namespaceramses.html#a5a24b250587d10d14d00389a8a74096aaaa3bf781f879d8c7bf83045abc831719">ramses::EClearFlags_None</a>);</div><div class="line"></div><div class="line">    <span class="comment">// set valid cameras for the passes</span></div><div class="line">    renderPassA-&gt;<a class="code" href="classramses_1_1RenderPass.html#a0a8ac513cd7bb87d08a8e96d1e678b6a">setCamera</a>(*cameraA);</div><div class="line">    renderPassB-&gt;<a class="code" href="classramses_1_1RenderPass.html#a0a8ac513cd7bb87d08a8e96d1e678b6a">setCamera</a>(*cameraB);</div><div class="line"></div><div class="line">    <span class="comment">// create render group for each renderpass</span></div><div class="line">    <a class="code" href="classramses_1_1RenderGroup.html">ramses::RenderGroup</a>* renderGroupA = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a7d3e0b1a87cb6a18ac64cb227f36f5e8">createRenderGroup</a>(<span class="stringliteral">&quot;rendergroup A&quot;</span>);</div><div class="line">    <a class="code" href="classramses_1_1RenderGroup.html">ramses::RenderGroup</a>* renderGroupB = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a7d3e0b1a87cb6a18ac64cb227f36f5e8">createRenderGroup</a>(<span class="stringliteral">&quot;rendergroup B&quot;</span>);</div><div class="line">    renderPassA-&gt;<a class="code" href="classramses_1_1RenderPass.html#a470ac8c21ca2b3157d9f006cbba946ac">addRenderGroup</a>(*renderGroupA);</div><div class="line">    renderPassB-&gt;<a class="code" href="classramses_1_1RenderPass.html#a470ac8c21ca2b3157d9f006cbba946ac">addRenderGroup</a>(*renderGroupB);</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1Appearance.html">ramses::Appearance</a>* appearanceA = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a5980a75ccc0e21f175f6d75803fb9d2b">createAppearance</a>(*effectTex, <span class="stringliteral">&quot;triangle appearance&quot;</span>);</div><div class="line">    <a class="code" href="classramses_1_1Appearance.html">ramses::Appearance</a>* appearanceB = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a5980a75ccc0e21f175f6d75803fb9d2b">createAppearance</a>(*effectTex, <span class="stringliteral">&quot;triangle appearance&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// set vertex positions directly in geometry</span></div><div class="line">    <a class="code" href="classramses_1_1GeometryBinding.html">ramses::GeometryBinding</a>* geometry = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a45950bffee8db288152f030f8b95736b">createGeometryBinding</a>(*effectTex, <span class="stringliteral">&quot;triangle geometry&quot;</span>);</div><div class="line">    geometry-&gt;<a class="code" href="classramses_1_1GeometryBinding.html#aaa304ccc5bbcb658cec3f6fa936426ef">setIndices</a>(*indices);</div><div class="line">    <a class="code" href="classramses_1_1AttributeInput.html">ramses::AttributeInput</a> positionsInput;</div><div class="line">    effectTex-&gt;findAttributeInput(<span class="stringliteral">&quot;a_position&quot;</span>, positionsInput);</div><div class="line">    geometry-&gt;<a class="code" href="classramses_1_1GeometryBinding.html#aa5d2fbb568d5638a64e70ed19135a8e7">setInputBuffer</a>(positionsInput, *vertexPositions);</div><div class="line"></div><div class="line">    <span class="comment">// use two appearances, each with a different color for distinguishing the meshes</span></div><div class="line">    <a class="code" href="classramses_1_1UniformInput.html">ramses::UniformInput</a> color;</div><div class="line">    effectTex-&gt;findUniformInput(<span class="stringliteral">&quot;color&quot;</span>, color);</div><div class="line">    appearanceA-&gt;<a class="code" href="classramses_1_1Appearance.html#a5b29e6be97053f2a3aae5216806018f6">setInputValueVector4f</a>(color, 1.0f,0.0f,0.0f,1.0f);</div><div class="line">    appearanceB-&gt;<a class="code" href="classramses_1_1Appearance.html#a5b29e6be97053f2a3aae5216806018f6">setInputValueVector4f</a>(color, 0.0f,1.0f,0.0f,1.0f);</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1MeshNode.html">ramses::MeshNode</a>* meshNodeA = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a0b73e5ae2f197bf8e814eea743566a53">createMeshNode</a>(<span class="stringliteral">&quot;red triangle mesh node&quot;</span>);</div><div class="line">    meshNodeA-&gt;<a class="code" href="classramses_1_1MeshNode.html#a03307af9bb4e533eca06fd119f635481">setAppearance</a>(*appearanceA);</div><div class="line">    meshNodeA-&gt;<a class="code" href="classramses_1_1MeshNode.html#abf97e76c45b196bc3ee0eea5fac8032e">setGeometryBinding</a>(*geometry);</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1MeshNode.html">ramses::MeshNode</a>* meshNodeB = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a0b73e5ae2f197bf8e814eea743566a53">createMeshNode</a>(<span class="stringliteral">&quot;green triangle mesh node&quot;</span>);</div><div class="line">    meshNodeB-&gt;<a class="code" href="classramses_1_1MeshNode.html#a03307af9bb4e533eca06fd119f635481">setAppearance</a>(*appearanceB);</div><div class="line">    meshNodeB-&gt;<a class="code" href="classramses_1_1MeshNode.html#abf97e76c45b196bc3ee0eea5fac8032e">setGeometryBinding</a>(*geometry);</div><div class="line"></div><div class="line">    <span class="comment">// add each mesh to one pass</span></div><div class="line">    renderGroupA-&gt;<a class="code" href="classramses_1_1RenderGroup.html#a78df5ac3c86bb456a5e7a62d76a60b12">addMeshNode</a>(*meshNodeA);</div><div class="line">    renderGroupB-&gt;<a class="code" href="classramses_1_1RenderGroup.html#a78df5ac3c86bb456a5e7a62d76a60b12">addMeshNode</a>(*meshNodeB);</div><div class="line"></div></div><!-- fragment --> <h2>Basic Render Target Handling</h2>
<p>This code shows the usage of a render target in combination with render passes. A render target can be assigned to a render pass, so the pass renders its meshes into a render target. The render target can be then used as texture input in a following render pass. </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line"></div><div class="line">    <span class="comment">// create a scene using explicit render passes</span></div><div class="line">    <a class="code" href="classramses_1_1Scene.html">ramses::Scene</a>* scene = <a class="code" href="namespaceramses.html">ramses</a>.createScene(<a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::sceneId_t</a>(123u), <a class="code" href="classramses_1_1SceneConfig.html">ramses::SceneConfig</a>(), <span class="stringliteral">&quot;basic rendertarget scene&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// every render pass needs a camera to define rendering parameters</span></div><div class="line">    <span class="comment">// usage of a custom perspective camera for the render pass assigned to the render target</span></div><div class="line">    <a class="code" href="classramses_1_1Node.html">ramses::Node</a>* cameraTranslate = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a24c2b19e21adcf073882fa0b8fd818d8">createNode</a>();</div><div class="line">    cameraTranslate-&gt;<a class="code" href="classramses_1_1Node.html#a8f8cb6996cd77f70f03ebc5a65fd37b4">setTranslation</a>(0.0f, 0.0f, 5.0f);</div><div class="line">    <a class="code" href="classramses_1_1PerspectiveCamera.html">ramses::PerspectiveCamera</a>* cameraA = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a861cc4650a056daada6f76b5d0c8ab7d">createPerspectiveCamera</a>(<span class="stringliteral">&quot;camera of renderpass A&quot;</span>);</div><div class="line">    cameraA-&gt;<a class="code" href="classramses_1_1Node.html#a323e05d9bccb97d0541c6ec3f730baf2">setParent</a>(*cameraTranslate);</div><div class="line">    cameraA-&gt;<a class="code" href="classramses_1_1PerspectiveCamera.html#aea24c939692f0a046b473cf6d0e16267">setFrustum</a>(-0.1f, 0.1f, -0.1f, 0.1f, 1.f, 10.f);</div><div class="line">    <span class="comment">// we want to render to the full extent of render target which has the resolution 64x64 (created later)</span></div><div class="line">    cameraA-&gt;<a class="code" href="classramses_1_1LocalCamera.html#aacf595ebc6dd8026ff0da01cb6af9be5">setViewport</a>(0u, 0u, 64u, 64u);</div><div class="line"></div><div class="line">    <span class="comment">// usage of global renderer camera for the resolving render pass</span></div><div class="line">    <a class="code" href="classramses_1_1Camera.html">ramses::Camera</a>* cameraB = scene-&gt;<a class="code" href="classramses_1_1Scene.html#aa0eec58fcfed1edb689e609d31e631b2">createRemoteCamera</a>(<span class="stringliteral">&quot;camera of renderpass B&quot;</span>);</div><div class="line">    cameraB-&gt;<a class="code" href="classramses_1_1Node.html#a323e05d9bccb97d0541c6ec3f730baf2">setParent</a>(*cameraTranslate);</div><div class="line"></div><div class="line">    <span class="comment">// create the renderpasses</span></div><div class="line">    <a class="code" href="classramses_1_1RenderPass.html">ramses::RenderPass</a>* renderPassA = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a5655e6484fda44cc3e9cccab2a939616">createRenderPass</a>(<span class="stringliteral">&quot;renderpass A&quot;</span>);</div><div class="line">    <a class="code" href="classramses_1_1RenderPass.html">ramses::RenderPass</a>* renderPassB = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a5655e6484fda44cc3e9cccab2a939616">createRenderPass</a>(<span class="stringliteral">&quot;renderpass B&quot;</span>);</div><div class="line">    renderPassB-&gt;<a class="code" href="classramses_1_1RenderPass.html#a0bb72789d6253e0e4a6706a5268a09eb">setClearFlags</a>(<a class="code" href="namespaceramses.html#a5a24b250587d10d14d00389a8a74096aaaa3bf781f879d8c7bf83045abc831719">ramses::EClearFlags_None</a>);</div><div class="line">    renderPassA-&gt;<a class="code" href="classramses_1_1RenderPass.html#ab45c5a53d4c6424577313168e65db853">setClearColor</a>(1.f, 1.f, 1.f, 1.f);</div><div class="line"></div><div class="line">    <span class="comment">// set valid cameras for the passes</span></div><div class="line">    renderPassA-&gt;<a class="code" href="classramses_1_1RenderPass.html#a0a8ac513cd7bb87d08a8e96d1e678b6a">setCamera</a>(*cameraA);</div><div class="line">    renderPassB-&gt;<a class="code" href="classramses_1_1RenderPass.html#a0a8ac513cd7bb87d08a8e96d1e678b6a">setCamera</a>(*cameraB);</div><div class="line"></div><div class="line">    <span class="comment">// create render group for each renderpass</span></div><div class="line">    <a class="code" href="classramses_1_1RenderGroup.html">ramses::RenderGroup</a>* renderGroupA = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a7d3e0b1a87cb6a18ac64cb227f36f5e8">createRenderGroup</a>(<span class="stringliteral">&quot;rendergroup A&quot;</span>);</div><div class="line">    <a class="code" href="classramses_1_1RenderGroup.html">ramses::RenderGroup</a>* renderGroupB = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a7d3e0b1a87cb6a18ac64cb227f36f5e8">createRenderGroup</a>(<span class="stringliteral">&quot;rendergroup B&quot;</span>);</div><div class="line">    renderPassA-&gt;<a class="code" href="classramses_1_1RenderPass.html#a470ac8c21ca2b3157d9f006cbba946ac">addRenderGroup</a>(*renderGroupA);</div><div class="line">    renderPassB-&gt;<a class="code" href="classramses_1_1RenderPass.html#a470ac8c21ca2b3157d9f006cbba946ac">addRenderGroup</a>(*renderGroupB);</div><div class="line"></div><div class="line">    <span class="comment">// create a render target and assign it to renderpass A</span></div><div class="line">    <a class="code" href="classramses_1_1RenderBuffer.html">ramses::RenderBuffer</a>* renderBuffer = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a37a2e6b17022b462499f01539c8835fd">createRenderBuffer</a>(64u, 64u, <a class="code" href="namespaceramses.html#ad588cb190910baf0625e1f3b26f2651fa43d145b777a5542493d48aaaf6ed952f">ramses::ERenderBufferType_Color</a>, <a class="code" href="namespaceramses.html#a112f8eaead740056b34faee3da8f3be0a58f471f775fe04ce80599ed7ea7d7024">ramses::ERenderBufferFormat_RGBA8</a>, <a class="code" href="namespaceramses.html#aefbff422a0f8775678c51995ccc5fd3cace5825b08123550adfaba35080625858">ramses::ERenderBufferAccessMode_ReadWrite</a>);</div><div class="line">    <a class="code" href="classramses_1_1RenderTargetDescription.html">ramses::RenderTargetDescription</a> rtDesc;</div><div class="line">    rtDesc.<a class="code" href="classramses_1_1RenderTargetDescription.html#ad53a028c0ebf4b64d303f2eb6453cf8a">addRenderBuffer</a>(*renderBuffer);</div><div class="line">    <a class="code" href="classramses_1_1RenderTarget.html">ramses::RenderTarget</a>* renderTarget = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a6e7e555a554c11c10329ce6c5afc8308">createRenderTarget</a>(rtDesc);</div><div class="line">    renderPassA-&gt;<a class="code" href="classramses_1_1RenderPass.html#a18b980fda0149e1a96be8e47dba2be4d">setRenderTarget</a>(renderTarget);</div><div class="line"></div><div class="line">    <span class="comment">// create triangle appearance, get input data and bind required data</span></div><div class="line">    <a class="code" href="classramses_1_1Appearance.html">ramses::Appearance</a>* appearanceA = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a5980a75ccc0e21f175f6d75803fb9d2b">createAppearance</a>(*triangleEffect, <span class="stringliteral">&quot;triangle appearance&quot;</span>);</div><div class="line">    {</div><div class="line">        <a class="code" href="classramses_1_1UniformInput.html">ramses::UniformInput</a> color;</div><div class="line">        triangleEffect-&gt;findUniformInput(<span class="stringliteral">&quot;color&quot;</span>, color);</div><div class="line">        appearanceA-&gt;<a class="code" href="classramses_1_1Appearance.html#a5b29e6be97053f2a3aae5216806018f6">setInputValueVector4f</a>(color, 1.0f, 0.0f, 0.0f, 1.0f);</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1GeometryBinding.html">ramses::GeometryBinding</a>* geometryA = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a45950bffee8db288152f030f8b95736b">createGeometryBinding</a>(*triangleEffect, <span class="stringliteral">&quot;triangle geometry&quot;</span>);</div><div class="line">    {</div><div class="line">        geometryA-&gt;<a class="code" href="classramses_1_1GeometryBinding.html#aaa304ccc5bbcb658cec3f6fa936426ef">setIndices</a>(*indicesTriangle);</div><div class="line">        <a class="code" href="classramses_1_1AttributeInput.html">ramses::AttributeInput</a> positionsInput;</div><div class="line">        triangleEffect-&gt;findAttributeInput(<span class="stringliteral">&quot;a_position&quot;</span>, positionsInput);</div><div class="line">        geometryA-&gt;<a class="code" href="classramses_1_1GeometryBinding.html#aa5d2fbb568d5638a64e70ed19135a8e7">setInputBuffer</a>(positionsInput, *vertexPositionsTriangle);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// create quad appearance, get input data and bind required data</span></div><div class="line">    <a class="code" href="classramses_1_1Appearance.html">ramses::Appearance</a>* appearanceB = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a5980a75ccc0e21f175f6d75803fb9d2b">createAppearance</a>(*quadEffect, <span class="stringliteral">&quot;quad appearance&quot;</span>);</div><div class="line">    {</div><div class="line">        <span class="comment">// create texture sampler with render target</span></div><div class="line">        <a class="code" href="classramses_1_1TextureSampler.html">ramses::TextureSampler</a>* sampler = scene-&gt;<a class="code" href="classramses_1_1Scene.html#af010635ec2c1838adbd0d4c8d3950b50">createTextureSampler</a>(</div><div class="line">            <a class="code" href="namespaceramses.html#a1fd1b9a27ae9cebb5c79e59794dc6c46a4a8af0047aff4ea71e7f35dd58f14223">ramses::ETextureAddressMode_Repeat</a>,</div><div class="line">            <a class="code" href="namespaceramses.html#a1fd1b9a27ae9cebb5c79e59794dc6c46a4a8af0047aff4ea71e7f35dd58f14223">ramses::ETextureAddressMode_Repeat</a>,</div><div class="line">            <a class="code" href="namespaceramses.html#a1a865d087e77ab22df621f6cfbebb8b7ad98f448d0353b6186863ddff164cca7c">ramses::ETextureSamplingMethod_Nearest</a>,</div><div class="line">            <a class="code" href="namespaceramses.html#a1a865d087e77ab22df621f6cfbebb8b7ad98f448d0353b6186863ddff164cca7c">ramses::ETextureSamplingMethod_Nearest</a>,</div><div class="line">            *renderBuffer);</div><div class="line"></div><div class="line">        <span class="comment">// set render target sampler as input</span></div><div class="line">        <a class="code" href="classramses_1_1UniformInput.html">ramses::UniformInput</a> textureInput;</div><div class="line">        quadEffect-&gt;findUniformInput(<span class="stringliteral">&quot;textureSampler&quot;</span>, textureInput);</div><div class="line">        appearanceB-&gt;<a class="code" href="classramses_1_1Appearance.html#ad4d48b8ec74600283ea5c1e414d249a3">setInputTexture</a>(textureInput, *sampler);</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1GeometryBinding.html">ramses::GeometryBinding</a>* geometryB = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a45950bffee8db288152f030f8b95736b">createGeometryBinding</a>(*quadEffect, <span class="stringliteral">&quot;quad geometry&quot;</span>);</div><div class="line">    {</div><div class="line">        geometryB-&gt;<a class="code" href="classramses_1_1GeometryBinding.html#aaa304ccc5bbcb658cec3f6fa936426ef">setIndices</a>(*indicesQuad);</div><div class="line">        <a class="code" href="classramses_1_1AttributeInput.html">ramses::AttributeInput</a> positionsInput;</div><div class="line">        <a class="code" href="classramses_1_1AttributeInput.html">ramses::AttributeInput</a> texcoordsInput;</div><div class="line">        quadEffect-&gt;findAttributeInput(<span class="stringliteral">&quot;a_position&quot;</span>, positionsInput);</div><div class="line">        quadEffect-&gt;findAttributeInput(<span class="stringliteral">&quot;a_texcoord&quot;</span>, texcoordsInput);</div><div class="line">        geometryB-&gt;<a class="code" href="classramses_1_1GeometryBinding.html#aa5d2fbb568d5638a64e70ed19135a8e7">setInputBuffer</a>(positionsInput, *vertexPositionsQuad);</div><div class="line">        geometryB-&gt;<a class="code" href="classramses_1_1GeometryBinding.html#aa5d2fbb568d5638a64e70ed19135a8e7">setInputBuffer</a>(texcoordsInput, *textureCoords);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// create meshs</span></div><div class="line">    <a class="code" href="classramses_1_1MeshNode.html">ramses::MeshNode</a>* meshNodeA = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a0b73e5ae2f197bf8e814eea743566a53">createMeshNode</a>(<span class="stringliteral">&quot;red triangle mesh node&quot;</span>);</div><div class="line">    meshNodeA-&gt;<a class="code" href="classramses_1_1MeshNode.html#a03307af9bb4e533eca06fd119f635481">setAppearance</a>(*appearanceA);</div><div class="line">    meshNodeA-&gt;<a class="code" href="classramses_1_1MeshNode.html#abf97e76c45b196bc3ee0eea5fac8032e">setGeometryBinding</a>(*geometryA);</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1MeshNode.html">ramses::MeshNode</a>* meshNodeB = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a0b73e5ae2f197bf8e814eea743566a53">createMeshNode</a>(<span class="stringliteral">&quot;texture quad mesh node&quot;</span>);</div><div class="line">    meshNodeB-&gt;<a class="code" href="classramses_1_1MeshNode.html#a03307af9bb4e533eca06fd119f635481">setAppearance</a>(*appearanceB);</div><div class="line">    meshNodeB-&gt;<a class="code" href="classramses_1_1MeshNode.html#abf97e76c45b196bc3ee0eea5fac8032e">setGeometryBinding</a>(*geometryB);</div><div class="line"></div><div class="line">    <span class="comment">// add triangle mesh to first pass and quad to second one</span></div><div class="line">    renderGroupA-&gt;<a class="code" href="classramses_1_1RenderGroup.html#a78df5ac3c86bb456a5e7a62d76a60b12">addMeshNode</a>(*meshNodeA);</div><div class="line">    renderGroupB-&gt;<a class="code" href="classramses_1_1RenderGroup.html#a78df5ac3c86bb456a5e7a62d76a60b12">addMeshNode</a>(*meshNodeB);</div><div class="line"></div></div><!-- fragment --> <h2>Basic Compositing</h2>
<p>This code creates a stream-texture that consists of a fallback texture and an id for mapping to a render-target. The renderer can replace the fallback texture by the content of a render-target, when the render-target is connected to the renderer. The id is an integer to identify the render-target. </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line"></div><div class="line">    <span class="comment">// texture</span></div><div class="line">    <a class="code" href="classramses_1_1Texture2D.html">ramses::Texture2D</a>* texture =</div><div class="line">        <a class="code" href="classramses_1_1RamsesUtils.html#a4bad26f4d83f7bce22980669fd5bd216">ramses::RamsesUtils::CreateTextureResourceFromPng</a>(<span class="stringliteral">&quot;res/ramses-example-basic-compositing-texture.png&quot;</span>, <a class="code" href="namespaceramses.html">ramses</a>);</div><div class="line"></div><div class="line">    <span class="comment">// use Texture2D as fallback for StreamTexture</span></div><div class="line">    <a class="code" href="classramses_1_1StreamTexture.html">ramses::StreamTexture</a>* streamTexture = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a5b28c51e4b40355e305d1d5608da9303">createStreamTexture</a>(*texture, static_cast&lt;ramses::streamSource_t&gt;(streamId), <span class="stringliteral">&quot;streamTexture&quot;</span>);</div><div class="line"></div></div><!-- fragment --> <h2>Data Buffers (vertices)</h2>
<p>This example creates a scene with a shape. Some of the shape's vertices are changed every frame and thus translated around the scene.</p>
<p>The first part of the example shows the setup of the data buffer objects. In contrast to ressources, data buffers get created via the scene (and are owned by the scene). </p><div class="fragment"><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line"></div><div class="line">    <span class="comment">// Create the DataBuffers</span></div><div class="line">    <span class="comment">// The data buffers need more information about size</span></div><div class="line">    <span class="keyword">const</span> uint32_t SizeOfVerticesInBytes = 16 * 3 * <span class="keyword">sizeof</span>(float);</div><div class="line">    <span class="keyword">const</span> uint32_t SizeOfIndicesInBytes  = 42 * <span class="keyword">sizeof</span>(uint16_t);</div><div class="line"></div><div class="line">    <span class="comment">// then create the buffers via the _scene_</span></div><div class="line">    <a class="code" href="classramses_1_1VertexDataBuffer.html">ramses::VertexDataBuffer</a>* vertices = scene-&gt;<a class="code" href="classramses_1_1Scene.html#ac88686b4f58941c6b1f5432756a353fc">createVertexDataBuffer</a>( SizeOfVerticesInBytes, <a class="code" href="namespaceramses.html#a6de13d29afe1f37ca41caec5ae20532cafb7f895c48d0e7d70b066acf73071bba">ramses::EDataType_Vector3F</a>, <span class="stringliteral">&quot;some varying vertices&quot;</span>);</div><div class="line">    <a class="code" href="classramses_1_1IndexDataBuffer.html">ramses::IndexDataBuffer</a>*  indices  = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a8d6bc487f4b6ae6350c97ecea08982ea">createIndexDataBuffer</a>(  SizeOfIndicesInBytes,  <a class="code" href="namespaceramses.html#a6de13d29afe1f37ca41caec5ae20532ca193bb6a3c7538076090cf766f3fddbb0">ramses::EDataType_UInt16</a>,   <span class="stringliteral">&quot;some varying indices&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// finally set/update the data</span></div><div class="line">    vertices-&gt;<a class="code" href="classramses_1_1VertexDataBuffer.html#a8c0d88f749077c528ae2d0c92510f52a">setData</a>(reinterpret_cast&lt;const char*&gt;(vertexPositions), SizeOfVerticesInBytes);</div><div class="line">    indices-&gt;<a class="code" href="classramses_1_1IndexDataBuffer.html#ac3a46b84c422ac768ee83d2f17aad3c5">setData</a>( reinterpret_cast&lt;const char*&gt;(indexData), SizeOfIndicesInBytes);</div><div class="line"></div></div><!-- fragment --><p>The second part of the example shows the application logic. A loop cycling over some of the vertices and changing their positions. These positions get applied to the data buffer by using <code>setData</code>. With <code>setData</code> you can set either the whole data buffer or just do partial updates using the optional offset parameter. </p><div class="fragment"><div class="line">    <span class="keyword">const</span> std::vector&lt;uint32_t&gt; ridges  = { 1, 7,  8, 14 };</div><div class="line">    <span class="keyword">const</span> std::vector&lt;uint32_t&gt; notches = { 3, 4, 11, 12 };</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint64_t timeStamp = 0u; timeStamp &lt; 10000u; timeStamp += 20u)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i: ridges)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">float</span> updatedValues[2];</div><div class="line">            <span class="keyword">const</span> uint32_t updatedValuesLength = 2 * <span class="keyword">sizeof</span>(float);</div><div class="line">            <span class="keyword">const</span> uint32_t offsetInDataBuffer  = i * 3u * <span class="keyword">sizeof</span>(float);</div><div class="line"></div><div class="line">            translateVertex(updatedValues, i, timeStamp, 0.25f);</div><div class="line">            vertices-&gt;<a class="code" href="classramses_1_1VertexDataBuffer.html#a8c0d88f749077c528ae2d0c92510f52a">setData</a>(reinterpret_cast&lt;const char*&gt;(updatedValues), updatedValuesLength, offsetInDataBuffer);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span>(<span class="keyword">auto</span> i: notches)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">float</span> updatedValues[2];</div><div class="line">            <span class="keyword">const</span> uint32_t updatedValuesLength = 2 * <span class="keyword">sizeof</span>(float);</div><div class="line">            <span class="keyword">const</span> uint32_t offsetInDataBuffer  = i * 3u * <span class="keyword">sizeof</span>(float);</div><div class="line"></div><div class="line">            translateVertex(updatedValues, i, timeStamp, -0.4f);</div><div class="line">            vertices-&gt;<a class="code" href="classramses_1_1VertexDataBuffer.html#a8c0d88f749077c528ae2d0c92510f52a">setData</a>(reinterpret_cast&lt;const char*&gt;(updatedValues), updatedValuesLength, offsetInDataBuffer);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// signal the scene it is in a state that can be rendered</span></div><div class="line">        scene-&gt;<a class="code" href="classramses_1_1Scene.html#ac12e7548df54a23bc10c1e5629c1aa88">flush</a>();</div><div class="line"></div><div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(20));</div><div class="line">    }</div></div><!-- fragment --> <h2>Data Buffers (textures)</h2>
<p>This example creates a scene with two quads. Each quad is showing the same texture. The difference between both quads is, that they are are showing different mipmap levels of the same texture. The texture's content within each mipmap layer is changed every frame.</p>
<p>The first part of the example shows the setup of the data buffer objects. In contrast to client resources, data buffers get created via the scene (and are owned by the scene). </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line"></div><div class="line">    <span class="comment">// Create the Texture2DBuffer via the scene</span></div><div class="line">    <a class="code" href="classramses_1_1Texture2DBuffer.html">ramses::Texture2DBuffer</a>* texture = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a50f721a5a9c81a3c00a3e0e0c72aec1a">createTexture2DBuffer</a>(2u, textureWidthLevel0, textureHeightLevel0, format, <span class="stringliteral">&quot;A varying texture&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Whith Texture2DBuffer::setData you can pass a buffer for a specific mipmap level</span></div><div class="line">    texture-&gt;<a class="code" href="classramses_1_1Texture2DBuffer.html#af513b2716b927866fae8a2f538db1007">setData</a>(reinterpret_cast&lt;const char*&gt;(textureDataLevel0.data()), 0, 0, 0, textureWidthLevel0, textureHeightLevel0);</div><div class="line">    texture-&gt;<a class="code" href="classramses_1_1Texture2DBuffer.html#af513b2716b927866fae8a2f538db1007">setData</a>(reinterpret_cast&lt;const char*&gt;(textureDataLevel1.data()), 1, 0, 0, textureWidthLevel1, textureHeightLevel1);</div><div class="line"></div><div class="line">    <span class="comment">// Just like resources or render buffers you add it via createTextureSampler</span></div><div class="line">    <a class="code" href="classramses_1_1TextureSampler.html">ramses::TextureSampler</a>* sampler = scene-&gt;<a class="code" href="classramses_1_1Scene.html#af010635ec2c1838adbd0d4c8d3950b50">createTextureSampler</a>(</div><div class="line">        <a class="code" href="namespaceramses.html#a1fd1b9a27ae9cebb5c79e59794dc6c46aaa518ec08d3daf24094f0401eeedad22">ramses::ETextureAddressMode_Clamp</a>,</div><div class="line">        <a class="code" href="namespaceramses.html#a1fd1b9a27ae9cebb5c79e59794dc6c46aaa518ec08d3daf24094f0401eeedad22">ramses::ETextureAddressMode_Clamp</a>,</div><div class="line">        <a class="code" href="namespaceramses.html#a1a865d087e77ab22df621f6cfbebb8b7ad98f448d0353b6186863ddff164cca7c">ramses::ETextureSamplingMethod_Nearest</a>,</div><div class="line">        <a class="code" href="namespaceramses.html#a1a865d087e77ab22df621f6cfbebb8b7ad98f448d0353b6186863ddff164cca7c">ramses::ETextureSamplingMethod_Nearest</a>,</div><div class="line">        *texture);</div></div><!-- fragment --><p>To change the data in the two mipmap levels, two data arrays (<code>regionDataLevel0</code> and <code>regionDataLevel1</code>) have been created. The size of these arrays is the size of the area to be changed (<code>regionWidth</code> and <code>regionHeight</code>).</p>
<p>In the following example you see a for-loop that calculates new pixel data for the two arrays. The array-data is then used with <code>setData</code> to update the data buffer. Other parameters in the <code>setData</code> call are the target mipmap level, and the dimensions.</p>
<p>Finally a <code>scene-&gt;flush()</code> is called to send the updated data to the renderer. </p><div class="fragment"><div class="line">    <span class="comment">// application logic</span></div><div class="line">    <span class="keywordflow">for</span>(uint32_t i=0; i &lt; 100; ++i)</div><div class="line">    {</div><div class="line">        <span class="comment">// The IndexIterator is just a helper class calculating the needed indices and positions</span></div><div class="line">        <span class="comment">// With regard to the example it&#39;s not important how these values are calculated.</span></div><div class="line">        IndexIterator&lt;textureWidthLevel0, textureHeightLevel0, regionOffsetXLevel0, regionOffsetYLevel0, regionWidthLevel0, regionHeightLevel0&gt; regionIndicesLevel0;</div><div class="line">        IndexIterator&lt;textureWidthLevel1, textureHeightLevel1, regionOffsetXLevel1, regionOffsetYLevel1, regionWidthLevel1, regionHeightLevel1&gt; regionIndicesLevel1;</div><div class="line"></div><div class="line">        <span class="comment">// cycleOffset is used to shift the calculated positions, thus creating the cycle effect</span></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> cycleOffset = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(i) / 10.f;</div><div class="line"></div><div class="line">        <span class="comment">// iterate over the values you want to update in mipmap level 0</span></div><div class="line">        <span class="keywordflow">for</span>(; !regionIndicesLevel0.isAtEnd(); ++regionIndicesLevel0)</div><div class="line">        {</div><div class="line">            <span class="keyword">const</span> uint32_t index = regionIndicesLevel0.getIndexLocal() * 3;</div><div class="line"></div><div class="line">            <span class="comment">// calculate new color values for the updated texture</span></div><div class="line">            <span class="comment">// these values can be stored in some new array, which is not necessarily the original</span></div><div class="line">            <span class="comment">// data array. This new array has to have the correct dimensions for the updated region</span></div><div class="line">            <span class="comment">// (i.e. might be just as small as the region you need to update)</span></div><div class="line">            regionDataLevel0.begin()[index+0] =  convertToUInt8(regionIndicesLevel0.getPositionXLocal(cycleOffset));</div><div class="line">            regionDataLevel0.begin()[index+1] =  0;</div><div class="line">            regionDataLevel0.begin()[index+2] =  convertToUInt8(regionIndicesLevel0.getPositionYLocal(cycleOffset));</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// iterate over the values you want to update in mipmap level 1</span></div><div class="line">        <span class="keywordflow">for</span>(; !regionIndicesLevel1.isAtEnd(); ++regionIndicesLevel1)</div><div class="line">        {</div><div class="line">            <span class="keyword">const</span> uint32_t index = regionIndicesLevel1.getIndexLocal() * 3;</div><div class="line">            regionDataLevel1.begin()[index+0] =  0;</div><div class="line">            regionDataLevel1.begin()[index+1] =  convertToUInt8(regionIndicesLevel1.getPositionXLocal(cycleOffset+0.5f));</div><div class="line">            regionDataLevel1.begin()[index+2] =  convertToUInt8(regionIndicesLevel1.getPositionYLocal(cycleOffset+0.3f));</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// with Texture2DBuffer::setData you can pass the updated array data to the data buffer</span></div><div class="line">        texture-&gt;<a class="code" href="classramses_1_1Texture2DBuffer.html#af513b2716b927866fae8a2f538db1007">setData</a>(reinterpret_cast&lt;const char*&gt;(regionDataLevel0.data()), 0, regionOffsetXLevel0, regionOffsetYLevel0, regionWidthLevel0, regionHeightLevel0);</div><div class="line">        texture-&gt;<a class="code" href="classramses_1_1Texture2DBuffer.html#af513b2716b927866fae8a2f538db1007">setData</a>(reinterpret_cast&lt;const char*&gt;(regionDataLevel1.data()), 1, regionOffsetXLevel1, regionOffsetYLevel1, regionWidthLevel1, regionHeightLevel1);</div><div class="line"></div><div class="line">        scene-&gt;<a class="code" href="classramses_1_1Scene.html#ac12e7548df54a23bc10c1e5629c1aa88">flush</a>();</div><div class="line"></div><div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(100));</div><div class="line">    }</div></div><!-- fragment --> <h2>Basic File/Asset Loading</h2>
<p>This code loads an asset (a serialized ramses scene). </p><div class="fragment"><div class="line">        <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">        <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line">        <a class="code" href="classramses_1_1ResourceFileDescriptionSet.html">ramses::ResourceFileDescriptionSet</a> resourceFileInformation;</div><div class="line">        resourceFileInformation.<a class="code" href="classramses_1_1ResourceFileDescriptionSet.html#a8b779d5f0cf3e0a7af09c8bc04aecdf2">add</a>(<a class="code" href="classramses_1_1ResourceFileDescription.html">ramses::ResourceFileDescription</a>(<span class="stringliteral">&quot;res/texture.ramres&quot;</span>));</div><div class="line">        resourceFileInformation.<a class="code" href="classramses_1_1ResourceFileDescriptionSet.html#a8b779d5f0cf3e0a7af09c8bc04aecdf2">add</a>(<a class="code" href="classramses_1_1ResourceFileDescription.html">ramses::ResourceFileDescription</a>(<span class="stringliteral">&quot;res/triangle.ramres&quot;</span>));</div><div class="line"></div><div class="line">        <a class="code" href="classramses_1_1Scene.html">ramses::Scene</a>* loadedScene = <a class="code" href="namespaceramses.html">ramses</a>.loadSceneFromFile(<span class="stringliteral">&quot;tempfile.ramses&quot;</span>, resourceFileInformation);</div><div class="line"></div><div class="line">        <span class="comment">// make changes to loaded scene</span></div><div class="line">        <a class="code" href="classramses_1_1RamsesObject.html">ramses::RamsesObject</a>* loadedObject = loadedScene-&gt;<a class="code" href="classramses_1_1Scene.html#ab1cc70b998f11fa845dcb0f021e8b50b">findObjectByName</a>(<span class="stringliteral">&quot;scale node&quot;</span>);</div><div class="line">        <a class="code" href="classramses_1_1Node.html">ramses::Node</a>* loadedScaleNode = ramses::RamsesUtils::TryConvert&lt;ramses::Node&gt;(*loadedObject);</div></div><!-- fragment --> <h2>Render Once Render Pass</h2>
<p>This code shows the usage of a render pass that is rendered only once into a render target. A heavy content that is mostly static can benefit from this feature where it is rendered only once or with low frequency and the result in form of a render buffer is used every frame in the main scene. </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line"></div><div class="line">    <span class="comment">// create the render once renderpass</span></div><div class="line">    <a class="code" href="classramses_1_1RenderPass.html">ramses::RenderPass</a>* renderPassRT = scene-&gt;<a class="code" href="classramses_1_1Scene.html#a5655e6484fda44cc3e9cccab2a939616">createRenderPass</a>(<span class="stringliteral">&quot;renderpass to render target&quot;</span>);</div><div class="line">    renderPassRT-&gt;<a class="code" href="classramses_1_1RenderPass.html#a0bb72789d6253e0e4a6706a5268a09eb">setClearFlags</a>(<a class="code" href="namespaceramses.html#a5a24b250587d10d14d00389a8a74096aa556030bb8824a49b1306408794389ea3">ramses::EClearFlags_All</a>);</div><div class="line">    renderPassRT-&gt;<a class="code" href="classramses_1_1RenderPass.html#ab45c5a53d4c6424577313168e65db853">setClearColor</a>(1.f, 1.f, 1.f, 1.f);</div><div class="line">    renderPassRT-&gt;<a class="code" href="classramses_1_1RenderPass.html#a0a8ac513cd7bb87d08a8e96d1e678b6a">setCamera</a>(*cameraA);</div><div class="line">    renderPassRT-&gt;<a class="code" href="classramses_1_1RenderPass.html#a6c21ecbb85839cdd1b335ffdde13408c">setRenderOnce</a>(<span class="keyword">true</span>);</div><div class="line"></div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="keywordflow">while</span> (--loops)</div><div class="line">    {</div><div class="line">        <span class="comment">// change color once per second</span></div><div class="line">        <span class="comment">// this will re-render the mesh to the render target only once per color change</span></div><div class="line">        std::this_thread::sleep_for(std::chrono::seconds(1));</div><div class="line">        appearanceA-&gt;<a class="code" href="classramses_1_1Appearance.html#a5b29e6be97053f2a3aae5216806018f6">setInputValueVector4f</a>(color, (loops % 2 ? 1.0f : 0.0f), 0.0f, (loops % 2 ? 0.0f : 1.0f), 1.0f);</div><div class="line">        renderPassRT-&gt;<a class="code" href="classramses_1_1RenderPass.html#a12cab56b855c8d3dc92da7e7bc7eb372">retriggerRenderOnce</a>();</div><div class="line">        scene-&gt;<a class="code" href="classramses_1_1Scene.html#ac12e7548df54a23bc10c1e5629c1aa88">flush</a>();</div><div class="line">    }</div></div><!-- fragment --> <h2>Multiple Displays</h2>
<p>This code creates a renderer with two displays and shows how a scene can be mapped to a display. </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line">    <span class="comment">// Create displays and map scenes to them</span></div><div class="line">    <a class="code" href="classramses_1_1DisplayConfig.html">ramses::DisplayConfig</a> displayConfig1(argc, argv);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::displayId_t</a> display1 = renderer.createDisplay(displayConfig1);</div><div class="line"></div><div class="line">    sceneControlAPI.setSceneMapping(sceneId1, display1);</div><div class="line">    sceneControlAPI.setSceneState(sceneId1, <a class="code" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82caa15a459a0439bde1ab6508bce7a05547">ramses::RendererSceneState::Rendered</a>);</div><div class="line">    sceneControlAPI.flush();</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1DisplayConfig.html">ramses::DisplayConfig</a> displayConfig2(argc, argv);</div><div class="line">    <span class="comment">//ivi surfaces must be unique for every display</span></div><div class="line">    displayConfig2.setWaylandIviSurfaceID(displayConfig1.getWaylandIviSurfaceID() + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::displayId_t</a> display2 = renderer.createDisplay(displayConfig2);</div><div class="line">    renderer.flush();</div><div class="line"></div><div class="line">    sceneControlAPI.setSceneMapping(sceneId2, display2);</div><div class="line">    sceneControlAPI.setSceneState(sceneId2, <a class="code" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82caa15a459a0439bde1ab6508bce7a05547">ramses::RendererSceneState::Rendered</a>);</div><div class="line">    sceneControlAPI.flush();</div><div class="line"></div></div><!-- fragment --> <h2>Data Linking</h2>
<p>This code creates two scenes, maps them to a display and shows how transformation data can be linked from one scene to the other.</p>
<p>Client side configuration: </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line"></div><div class="line">    <span class="comment">// Transformation links</span></div><div class="line">    <a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::dataProviderId_t</a> transformationProviderId(14u);</div><div class="line">    <a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::dataConsumerId_t</a> transformationConsumerId(12u);</div><div class="line">    <a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::dataConsumerId_t</a> transformationConsumerId2(87u);</div><div class="line"></div><div class="line">    triangleScene-&gt;createTransformationDataProvider(*providerNode, transformationProviderId);</div><div class="line">    quadScene-&gt;createTransformationDataConsumer(*consumerNode, transformationConsumerId);</div><div class="line">    quadScene2-&gt;createTransformationDataConsumer(*consumerNode2, transformationConsumerId2);</div><div class="line"></div><div class="line">    <span class="comment">//Data links</span></div><div class="line">    <a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::dataProviderId_t</a> dataProviderId(100u);</div><div class="line">    <a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::dataConsumerId_t</a> dataConsumerId(101u);</div><div class="line"></div><div class="line">    triangleScene-&gt;createDataConsumer(*triangleInfo-&gt;colorData, dataConsumerId);</div><div class="line">    quadScene-&gt;createDataProvider(*quadInfo-&gt;colorData, dataProviderId);</div><div class="line"></div><div class="line">    <span class="comment">//Texture links</span></div><div class="line">    <a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::dataProviderId_t</a> textureProviderId(200u);</div><div class="line">    <a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::dataConsumerId_t</a> textureConsumerId(201u);</div><div class="line"></div><div class="line">    triangleScene-&gt;createTextureProvider(*triangleInfo-&gt;textures[0], textureProviderId);</div><div class="line">    quadScene2-&gt;createTextureConsumer(*quadInfo2-&gt;textureSampler, textureConsumerId);</div><div class="line"></div><div class="line">    triangleScene-&gt;flush();</div><div class="line">    quadScene-&gt;flush();</div><div class="line">    quadScene2-&gt;flush();</div><div class="line"></div></div><!-- fragment --><p>Renderer side link creation: </p><div class="fragment"><div class="line">    <span class="comment">// link transformation</span></div><div class="line">    sceneControlAPI.linkData(triangleSceneId, transformationProviderId, quadSceneId, transformationConsumerId);</div><div class="line">    sceneControlAPI.linkData(triangleSceneId, transformationProviderId, quadSceneId2, transformationConsumerId2);</div><div class="line">    <span class="comment">// link data</span></div><div class="line">    sceneControlAPI.linkData(quadSceneId, dataProviderId, triangleSceneId, dataConsumerId);</div><div class="line">    <span class="comment">// link texture</span></div><div class="line">    sceneControlAPI.linkData(triangleSceneId, textureProviderId, quadSceneId2, textureConsumerId);</div></div><!-- fragment --> <h2>Viewport Linking</h2>
<p>This code creates two scenes with content and a master scene. The master scene is only used to control position and size of the other two scenes (in 2D) using data linking - it links viewport parameters to the other scenes' cameras. The master scene has no knowledge of the other scenes except for their camera viewport data consumer IDs.</p>
<p>Content side setup: </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line">    <span class="comment">// Bind data objects to scene&#39;s camera viewport offset/size and mark as data consumers</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> vpOffsetData = clientScene-&gt;createDataVector2i(<span class="stringliteral">&quot;vpOffset&quot;</span>);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> vpSizeData = clientScene-&gt;createDataVector2i(<span class="stringliteral">&quot;vpSize&quot;</span>);</div><div class="line">    vpOffsetData-&gt;setValue(0, 0);</div><div class="line">    vpSizeData-&gt;setValue(VPWidth, VPHeight);</div><div class="line">    camera-&gt;<a class="code" href="classramses_1_1LocalCamera.html#a5fcf8ebe2a1e3d1b40c8323e5f55d15f">bindViewportOffset</a>(*vpOffsetData);</div><div class="line">    camera-&gt;<a class="code" href="classramses_1_1LocalCamera.html#a7ca72874a1e63390ffb97f1213670c71">bindViewportSize</a>(*vpSizeData);</div><div class="line">    clientScene-&gt;createDataConsumer(*vpOffsetData, VPOffsetConsumerId);</div><div class="line">    clientScene-&gt;createDataConsumer(*vpSizeData, VPSizeConsumerId);</div></div><!-- fragment --><p>Master scene side setup: </p><div class="fragment"><div class="line">    <span class="comment">// In master scene create data objects and mark them as providers to control other scenes&#39; viewports</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> vp1offset = clientScene-&gt;createDataVector2i(<span class="stringliteral">&quot;vp1offset&quot;</span>);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> vp1size = clientScene-&gt;createDataVector2i(<span class="stringliteral">&quot;vp1size&quot;</span>);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> vp2offset = clientScene-&gt;createDataVector2i(<span class="stringliteral">&quot;vp2offset&quot;</span>);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> vp2size = clientScene-&gt;createDataVector2i(<span class="stringliteral">&quot;vp2size&quot;</span>);</div><div class="line"></div><div class="line">    vp1offset-&gt;setValue(0, 0);</div><div class="line">    vp1size-&gt;setValue(DispWidth, DispHeight);</div><div class="line">    vp2offset-&gt;setValue(0, 0);</div><div class="line">    vp2size-&gt;setValue(DispWidth, DispHeight);</div><div class="line"></div><div class="line">    clientScene-&gt;createDataProvider(*vp1offset, VP1OffsetProviderId);</div><div class="line">    clientScene-&gt;createDataProvider(*vp1size, VP1SizeProviderId);</div><div class="line">    clientScene-&gt;createDataProvider(*vp2offset, VP2OffsetProviderId);</div><div class="line">    clientScene-&gt;createDataProvider(*vp2size, VP2SizeProviderId);</div></div><!-- fragment --><p>Linking together: </p><div class="fragment"><div class="line">    <span class="comment">// Link master scene&#39;s data objects to other scenes cameras&#39; viewports</span></div><div class="line">    sceneControlAPI.linkData(sceneIdMaster, VP1OffsetProviderId, sceneId1, VPOffsetConsumerId);</div><div class="line">    sceneControlAPI.linkData(sceneIdMaster, VP1SizeProviderId, sceneId1, VPSizeConsumerId);</div><div class="line">    sceneControlAPI.linkData(sceneIdMaster, VP2OffsetProviderId, sceneId2, VPOffsetConsumerId);</div><div class="line">    sceneControlAPI.linkData(sceneIdMaster, VP2SizeProviderId, sceneId2, VPSizeConsumerId);</div><div class="line">    sceneControlAPI.flush();</div></div><!-- fragment --> <h2>Offscreen Buffer</h2>
<p>This code creates a scene with a triangle and a texture consumer, then creates a second scene and renders it into an offscreen buffer. The offscreen buffer is then linked to the first scene so that it is used as a texture on the triangle. </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line"></div><div class="line">    <span class="comment">// Create texture consumer that will use offscreen buffer to sample from</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::dataConsumerId_t</a> samplerConsumerId(456u);</div><div class="line">    scene1-&gt;createTextureConsumer(*textureSamplerConsumer, samplerConsumerId);</div><div class="line">    <span class="comment">// flush with version tag and wait for flush applied to make sure consumer is created</span></div><div class="line">    <a class="code" href="namespaceramses.html#ab7aa6bed4d47d2bd0967fc1a5ed6e95b">ramses::sceneVersionTag_t</a> versionTag{ 42 };</div><div class="line">    scene1-&gt;flush(versionTag);</div><div class="line">    eventHandler.waitForFlush(sceneId1, versionTag);</div><div class="line"></div><div class="line">    <span class="comment">// Create an offscreen buffer - has to be on the same display where both the scene to be rendered into it is mapped and the scene to consume it is mapped</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::displayBufferId_t</a> offscreenBuffer = renderer.createOffscreenBuffer(display, 200u, 200u);</div><div class="line">    renderer.flush();</div><div class="line">    eventHandler.waitForOffscreenBufferCreated(offscreenBuffer);</div><div class="line"></div><div class="line">    <span class="comment">// Assign the second scene to the offscreen buffer</span></div><div class="line">    <span class="comment">// This means scene is not going to be rendered on the display but to the offscreen buffer instead</span></div><div class="line">    sceneControlAPI.setSceneDisplayBufferAssignment(sceneId2, offscreenBuffer);</div><div class="line">    sceneControlAPI.flush();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// Link the offscreen buffer to first scene texture sampler so that the content will be used as texture</span></div><div class="line">    sceneControlAPI.linkOffscreenBuffer(offscreenBuffer, sceneId1, samplerConsumerId);</div><div class="line">    sceneControlAPI.flush();</div><div class="line">    eventHandler.waitForOffscreenBufferLinkedToConsumingScene(sceneId1);</div><div class="line"></div><div class="line">    <span class="comment">// Now both scenes can be rendered at the same time</span></div><div class="line">    sceneControlAPI.setSceneState(sceneId1, <a class="code" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82caa15a459a0439bde1ab6508bce7a05547">ramses::RendererSceneState::Rendered</a>);</div><div class="line">    sceneControlAPI.setSceneState(sceneId2, <a class="code" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82caa15a459a0439bde1ab6508bce7a05547">ramses::RendererSceneState::Rendered</a>);</div><div class="line">    sceneControlAPI.flush();</div></div><!-- fragment --> <h2>Pick Handling</h2>
<p>This code creates a scene with two triangles and two pickable objects exactly covering these two triangles. The pickable objects use the scenes camera. This is needed for the intersection algorithm to unproject the pick ray in the same space as the object in the scene, that should be picked. When the user clicks on either of the two triangles in the renderer window the triangles change color. </p><div class="fragment"><div class="line">    <span class="comment">// use triangle&#39;s vertex position array as PickableObject geometry</span></div><div class="line">    <span class="comment">// the two PickableObjects are exactly covering the two triangles</span></div><div class="line">    <a class="code" href="classramses_1_1VertexDataBuffer.html">ramses::VertexDataBuffer</a>* pickableGeometryBuffer = clientScene-&gt;createVertexDataBuffer(<span class="keyword">sizeof</span>(vertexPositionsArray), <a class="code" href="namespaceramses.html#a6de13d29afe1f37ca41caec5ae20532cafb7f895c48d0e7d70b066acf73071bba">ramses::EDataType_Vector3F</a>, <span class="stringliteral">&quot;geometryBuffer&quot;</span>);</div><div class="line">    pickableGeometryBuffer-&gt;<a class="code" href="classramses_1_1VertexDataBuffer.html#a8c0d88f749077c528ae2d0c92510f52a">setData</a>(reinterpret_cast&lt;const char*&gt;(vertexPositionsArray), <span class="keyword">sizeof</span>(vertexPositionsArray));</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1PickableObject.html">ramses::PickableObject</a>* pickableObject1 =  clientScene-&gt;createPickableObject(*pickableGeometryBuffer, <a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::pickableObjectId_t</a>(1), <span class="stringliteral">&quot;pickableObject&quot;</span>);</div><div class="line">    pickableObject1-&gt;<a class="code" href="classramses_1_1Node.html#a323e05d9bccb97d0541c6ec3f730baf2">setParent</a>(*meshNode);</div><div class="line">    <span class="comment">// use the scenes camera for calculating the right intersection point with the PickableObject</span></div><div class="line">    pickableObject1-&gt;<a class="code" href="classramses_1_1PickableObject.html#a790d7f9e5b42e19182908867f17b1610">setCamera</a>(*perspectiveCamera);</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1PickableObject.html">ramses::PickableObject</a>* pickableObject2 = clientScene-&gt;createPickableObject(*pickableGeometryBuffer, <a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::pickableObjectId_t</a>(2), <span class="stringliteral">&quot;pickableObject2&quot;</span>);</div><div class="line">    pickableObject2-&gt;<a class="code" href="classramses_1_1Node.html#a323e05d9bccb97d0541c6ec3f730baf2">setParent</a>(*meshNode2);</div><div class="line">    pickableObject2-&gt;<a class="code" href="classramses_1_1PickableObject.html#a790d7f9e5b42e19182908867f17b1610">setCamera</a>(*orthographicCamera);</div><div class="line"></div><div class="line">    clientScene-&gt;publish();</div><div class="line">    clientScene-&gt;flush();</div><div class="line"></div><div class="line">    SceneStateEventHandler eventHandler(sceneControlAPI, *appearanceA, *appearanceB, colorInput);</div><div class="line"></div><div class="line">    <span class="comment">// show the scene on the renderer</span></div><div class="line">    sceneControlAPI.setSceneMapping(sceneId, display);</div><div class="line">    sceneControlAPI.setSceneState(sceneId, <a class="code" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82caa15a459a0439bde1ab6508bce7a05547">ramses::RendererSceneState::Rendered</a>);</div><div class="line">    sceneControlAPI.flush();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (;;)</div><div class="line">    {</div><div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(15));</div><div class="line">        renderer.dispatchEvents(eventHandler);</div><div class="line">        sceneControlAPI.dispatchEvents(eventHandler);</div><div class="line">        <span class="comment">// signal the scene it is in a state that can be rendered</span></div><div class="line">        clientScene-&gt;flush();</div><div class="line">        sceneControlAPI.flush();</div><div class="line">        renderer.flush();</div></div><!-- fragment --> <h2>Basic Text</h2>
<p>This code creates a basic text using a text API. </p><div class="fragment"><div class="line">    <span class="comment">// IMPORTANT NOTE: For simplicity and readability the example code does not check return values from API calls.</span></div><div class="line">    <span class="comment">//                 This should not be the case for real applications.</span></div><div class="line"></div><div class="line">    <span class="comment">// Text is rendered in a screen-space pixel precise coordinate system</span></div><div class="line">    <span class="comment">// To achieve a texel-to-pixel ratio of 1 when rendering the text, it has to be</span></div><div class="line">    <span class="comment">// rendered with an orthographic camera with planes matching the display size (pixel buffer)</span></div><div class="line">    <span class="keyword">const</span> uint32_t displayWidth(1280);</div><div class="line">    <span class="keyword">const</span> uint32_t displayHeight(480);</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1RamsesFramework.html">ramses::RamsesFramework</a> framework(argc, argv);</div><div class="line">    <a class="code" href="classramses_1_1RamsesClient.html">ramses::RamsesClient</a>&amp; client(*framework.createClient(<span class="stringliteral">&quot;ExampleTextBasic&quot;</span>));</div><div class="line"></div><div class="line">    <a class="code" href="classramses_1_1Scene.html">ramses::Scene</a>* scene = client.createScene(<a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::sceneId_t</a>(123u));</div><div class="line"></div><div class="line">    <span class="comment">// create font registry to hold font memory and text cache to cache text meshes</span></div><div class="line">    <a class="code" href="classramses_1_1FontRegistry.html">ramses::FontRegistry</a> fontRegistry;</div><div class="line">    <a class="code" href="classramses_1_1TextCache.html">ramses::TextCache</a> textCache(*scene, fontRegistry, 1024u, 1024u);</div><div class="line"></div><div class="line">    framework.connect();</div><div class="line"></div><div class="line">    <span class="comment">// Create orthographic camera, so that text pixels will match screen pixels</span></div><div class="line">    <a class="code" href="classramses_1_1OrthographicCamera.html">ramses::OrthographicCamera</a>* camera = scene-&gt;createOrthographicCamera();</div><div class="line">    camera-&gt;<a class="code" href="classramses_1_1LocalCamera.html#a2ad45b979f1aa239ca30bfa53f379d52">setFrustum</a>(0.0f, static_cast&lt;float&gt;(displayWidth), 0.0f, static_cast&lt;float&gt;(displayHeight), 0.1f, 1.f);</div><div class="line">    camera-&gt;<a class="code" href="classramses_1_1LocalCamera.html#aacf595ebc6dd8026ff0da01cb6af9be5">setViewport</a>(0, 0, displayWidth, displayHeight);</div><div class="line"></div><div class="line">    <span class="comment">// create render pass</span></div><div class="line">    <a class="code" href="classramses_1_1RenderPass.html">ramses::RenderPass</a>* renderPass = scene-&gt;createRenderPass();</div><div class="line">    renderPass-&gt;<a class="code" href="classramses_1_1RenderPass.html#a0bb72789d6253e0e4a6706a5268a09eb">setClearFlags</a>(<a class="code" href="namespaceramses.html#a5a24b250587d10d14d00389a8a74096aaaa3bf781f879d8c7bf83045abc831719">ramses::EClearFlags_None</a>);</div><div class="line">    renderPass-&gt;<a class="code" href="classramses_1_1RenderPass.html#a0a8ac513cd7bb87d08a8e96d1e678b6a">setCamera</a>(*camera);</div><div class="line">    <a class="code" href="classramses_1_1RenderGroup.html">ramses::RenderGroup</a>* renderGroup = scene-&gt;createRenderGroup();</div><div class="line">    renderPass-&gt;<a class="code" href="classramses_1_1RenderPass.html#a470ac8c21ca2b3157d9f006cbba946ac">addRenderGroup</a>(*renderGroup);</div><div class="line"></div><div class="line">    <span class="comment">// create appearance to be used for text</span></div><div class="line">    <a class="code" href="classramses_1_1EffectDescription.html">ramses::EffectDescription</a> effectDesc;</div><div class="line">    effectDesc.<a class="code" href="classramses_1_1EffectDescription.html#a9213d2b7a1d5cb4714f147e27ddd980c">setAttributeSemantic</a>(<span class="stringliteral">&quot;a_position&quot;</span>, <a class="code" href="namespaceramses.html#ad7f84ff9db0a84f73a32b87d330a5c79ac32ce0999130c3c23abeea8943f6096b">ramses::EEffectAttributeSemantic_TextPositions</a>);</div><div class="line">    effectDesc.<a class="code" href="classramses_1_1EffectDescription.html#a9213d2b7a1d5cb4714f147e27ddd980c">setAttributeSemantic</a>(<span class="stringliteral">&quot;a_texcoord&quot;</span>, <a class="code" href="namespaceramses.html#ad7f84ff9db0a84f73a32b87d330a5c79a57b7b57b8fdd6e153c396aeb7f9baf36">ramses::EEffectAttributeSemantic_TextTextureCoordinates</a>);</div><div class="line">    effectDesc.<a class="code" href="classramses_1_1EffectDescription.html#aa6441d0d110fd4fb04f9e5d2a471c4da">setUniformSemantic</a>(<span class="stringliteral">&quot;u_texture&quot;</span>, <a class="code" href="namespaceramses.html#a62ffd4eb754f4139d86eec8b4529529fa3724da948cd2118537a36ec25136c59d">ramses::EEffectUniformSemantic_TextTexture</a>);</div><div class="line">    effectDesc.<a class="code" href="classramses_1_1EffectDescription.html#aa6441d0d110fd4fb04f9e5d2a471c4da">setUniformSemantic</a>(<span class="stringliteral">&quot;mvpMatrix&quot;</span>, <a class="code" href="namespaceramses.html#a62ffd4eb754f4139d86eec8b4529529fa72ccdf009a23222118b1c8ea7cd60703">ramses::EEffectUniformSemantic_ModelViewProjectionMatrix</a>);</div><div class="line">    effectDesc.<a class="code" href="classramses_1_1EffectDescription.html#aa08514cddaf554eb165ebfd0ae20be45">setVertexShaderFromFile</a>(<span class="stringliteral">&quot;res/ramses-example-text-basic-effect.vert&quot;</span>);</div><div class="line">    effectDesc.<a class="code" href="classramses_1_1EffectDescription.html#aeb8695b36a1d62720b26bc5e32ee3702">setFragmentShaderFromFile</a>(<span class="stringliteral">&quot;res/ramses-example-text-basic-effect.frag&quot;</span>);</div><div class="line">    <a class="code" href="classramses_1_1Effect.html">ramses::Effect</a>* textEffect = client.createEffect(effectDesc, <a class="code" href="namespaceramses.html#aa4f32a02a4d27b0759cf54915b6ce602">ramses::ResourceCacheFlag_DoNotCache</a>, <span class="stringliteral">&quot;simpleTextShader&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// create font instance</span></div><div class="line">    <a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::FontId</a> font = fontRegistry.<a class="code" href="classramses_1_1FontRegistry.html#adf7913b93f629e241ab11f936705c49d">createFreetype2Font</a>(<span class="stringliteral">&quot;res/ramses-example-text-basic-Roboto-Bold.ttf&quot;</span>);</div><div class="line">    <a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::FontInstanceId</a> fontInstance = fontRegistry.<a class="code" href="classramses_1_1FontRegistry.html#a47e62f1d6b99fcaeded6929a93128e6d">createFreetype2FontInstance</a>(font, 64);</div><div class="line"></div><div class="line">    <span class="comment">// load rasterized glyphs for each character</span></div><div class="line">    <span class="keyword">const</span> std::u32string <span class="keywordtype">string</span> = U<span class="stringliteral">&quot;Hello World!&quot;</span>;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceramses.html#ae9c5e75c9066f4b607272c9602c1bb7c">ramses::GlyphMetricsVector</a> positionedGlyphs = textCache.getPositionedGlyphs(<span class="keywordtype">string</span>, fontInstance);</div><div class="line"></div><div class="line">    <span class="comment">// create RAMSES meshes/texture page to hold the glyphs and text geometry</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classramses_1_1StronglyTypedValue.html">ramses::TextLineId</a> textId = textCache.createTextLine(positionedGlyphs, *textEffect);</div><div class="line">    <a class="code" href="structramses_1_1TextLine.html">ramses::TextLine</a>* textLine = textCache.getTextLine(textId);</div><div class="line"></div><div class="line">    textLine-&gt;<a class="code" href="structramses_1_1TextLine.html#a04c8cacfcad1da07b04228156ac04822">meshNode</a>-&gt;<a class="code" href="classramses_1_1MeshNode.html#a1949667b7361191ec10b267b89a00d8d">getAppearance</a>()-&gt;<a class="code" href="classramses_1_1Appearance.html#ab531ef91175d2178991b87c29d34d098">setBlendingOperations</a>(<a class="code" href="namespaceramses.html#ae003c64dd1ee017a9c7afda5070c5277ab073260c68c58d39df3df7cf524bab5e">ramses::EBlendOperation_Add</a>, <a class="code" href="namespaceramses.html#ae003c64dd1ee017a9c7afda5070c5277ab073260c68c58d39df3df7cf524bab5e">ramses::EBlendOperation_Add</a>);</div><div class="line">    textLine-&gt;<a class="code" href="structramses_1_1TextLine.html#a04c8cacfcad1da07b04228156ac04822">meshNode</a>-&gt;<a class="code" href="classramses_1_1MeshNode.html#a1949667b7361191ec10b267b89a00d8d">getAppearance</a>()-&gt;<a class="code" href="classramses_1_1Appearance.html#ac19d7763ed7ff2530811a3776d278047">setBlendingFactors</a>(<a class="code" href="namespaceramses.html#ad92db747f446d34174fe02bc106db60aad4ea42d780d57674c049cded1e23b870">ramses::EBlendFactor_SrcAlpha</a>, <a class="code" href="namespaceramses.html#ad92db747f446d34174fe02bc106db60aa38ca3aa38628208af2024f75d781ed08">ramses::EBlendFactor_OneMinusSrcAlpha</a>, <a class="code" href="namespaceramses.html#ad92db747f446d34174fe02bc106db60aad4ea42d780d57674c049cded1e23b870">ramses::EBlendFactor_SrcAlpha</a>, <a class="code" href="namespaceramses.html#ad92db747f446d34174fe02bc106db60aa38ca3aa38628208af2024f75d781ed08">ramses::EBlendFactor_OneMinusSrcAlpha</a>);</div><div class="line"></div><div class="line">    <span class="comment">// add the text meshes to the render pass to show them</span></div><div class="line">    textLine-&gt;<a class="code" href="structramses_1_1TextLine.html#a04c8cacfcad1da07b04228156ac04822">meshNode</a>-&gt;<a class="code" href="classramses_1_1Node.html#a8f8cb6996cd77f70f03ebc5a65fd37b4">setTranslation</a>(20.0f, 20.0f, -0.5f);</div><div class="line">    renderGroup-&gt;<a class="code" href="classramses_1_1RenderGroup.html#a78df5ac3c86bb456a5e7a62d76a60b12">addMeshNode</a>(*textLine-&gt;<a class="code" href="structramses_1_1TextLine.html#a04c8cacfcad1da07b04228156ac04822">meshNode</a>);</div><div class="line"></div><div class="line">    <span class="comment">// apply changes</span></div><div class="line">    scene-&gt;flush();</div></div><!-- fragment --> <h2>DCSM Provider</h2>
<p>This code offers a small scene via DCSM and is able to resize it and run a hide/show animation. A renderer side application which is supposed to work with this example properly needs to understand the DCSM protocol. For the standalone renderer this can be enabled with the "-dcsm" command line parameter.</p>
<h2>Scene referencing</h2>
<p>This code creates two scenes with content and a master scene. The master scene is only used to control position and size of the other two scenes (in 2D) using data linking - it links viewport parameters to the other scenes' cameras. The master scene has no knowledge of the other scenes except for their camera viewport data consumer IDs. The example also shows how a client can control rendering states of other scenes without access to renderer API.</p>
<p>Create scene references and get the to a rendered state: </p><div class="fragment"><div class="line">    <span class="comment">// create a scene reference for both scenes</span></div><div class="line">    <a class="code" href="classramses_1_1SceneReference.html">ramses::SceneReference</a>* sceneRef1 = masterScene-&gt;createSceneReference(refSceneId1);</div><div class="line">    <a class="code" href="classramses_1_1SceneReference.html">ramses::SceneReference</a>* sceneRef2 = masterScene-&gt;createSceneReference(refSceneId2);</div><div class="line"></div><div class="line">    <span class="comment">// request scene references state to rendered, they will be brought to state rendered alongside with master scene</span></div><div class="line">    sceneRef1-&gt;<a class="code" href="classramses_1_1SceneReference.html#a3805360018d331b1d5c74fac8b5e7bd4">requestState</a>(<a class="code" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82caa15a459a0439bde1ab6508bce7a05547">ramses::RendererSceneState::Rendered</a>);</div><div class="line">    sceneRef2-&gt;<a class="code" href="classramses_1_1SceneReference.html#a3805360018d331b1d5c74fac8b5e7bd4">requestState</a>(<a class="code" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82caa15a459a0439bde1ab6508bce7a05547">ramses::RendererSceneState::Rendered</a>);</div><div class="line">    masterScene-&gt;flush();</div></div><!-- fragment --><p>Link viewport via scene referencing: </p><div class="fragment"><div class="line">    <span class="comment">// wait for referenced scene to be available, before trying to data link</span></div><div class="line">    SceneReferenceEventHandler eventHandler(client);</div><div class="line">    eventHandler.waitForSceneRefState(refSceneId1, <a class="code" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82ca78945de8de090e90045d299651a68a9b">ramses::RendererSceneState::Available</a>);</div><div class="line">    eventHandler.waitForSceneRefState(refSceneId2, <a class="code" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82ca78945de8de090e90045d299651a68a9b">ramses::RendererSceneState::Available</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Link master scene&#39;s data objects to other scenes cameras&#39; viewports</span></div><div class="line">    masterScene-&gt;linkData(<span class="keyword">nullptr</span>, VP1OffsetProviderId, sceneRef1, VPOffsetConsumerId);</div><div class="line">    masterScene-&gt;linkData(<span class="keyword">nullptr</span>, VP1SizeProviderId, sceneRef1, VPSizeConsumerId);</div><div class="line">    masterScene-&gt;linkData(<span class="keyword">nullptr</span>, VP2OffsetProviderId, sceneRef2, VPOffsetConsumerId);</div><div class="line">    masterScene-&gt;linkData(<span class="keyword">nullptr</span>, VP2SizeProviderId, sceneRef2, VPSizeConsumerId);</div><div class="line">    masterScene-&gt;flush();</div></div><!-- fragment --></div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
