<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAMSES Documentation: The Display Cluster State Management Protocol</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ramses_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RAMSES Documentation
   &#160;<span id="projectnumber">25.0.6</span>
   </div>
   <div id="projectbrief">Information for RAMSES users and developers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The Display Cluster State Management Protocol </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>What is DCSM</h1>
<p>DCSM stands for Display Cluster State Management. It is a protocol which enables the provider and the consumer of any distributable or streamed graphical content to negotiate about the current state of the graphical content, e.g. if the content is supposed to be shown or not. The DCSM protocol is designed to work for any graphical content, be it video streams or rendered computer graphics content. Additionally to the state changes, it allows to synchronize between provider and consumer about the size of the content and about transition animations into new sizes and new content states.</p>
<h1>Consumer and Provider</h1>
<p>The Consumer is the part of the system, which owns the display and is able to show received Content on that display. The Provider is the part of the system, which owns and controls the actual graphical content and makes it available to the Consumer. The design of the protocol puts the Consumer in charge of what is being shown when and in which size. The Provider controls, what is available for being shown and how the graphical content looks.</p>
<p>There can be multiple Consumers and Providers in a DCSM system. Providers offer their Content to all Consumers, but a Content might only be assigned to one Consumer at a time.</p>
<h1>Content States</h1>
<p>The Content may be in different states. The protocol is used to synchronize those states between Consumer and Provider.</p>
<p><b>Offered</b><br />
 This is the initial state of every Content after it has been created by the provider. It means the graphical content could be made available for any interested Consumer. The Provider will announce the potential availability to all connected and future Consumers. The actual graphical content may not even exist yet.</p>
<p>A Content is always offered for exactly one Category. This is an application defined value which indicates in which context this graphical content is supposed to be used. Each Category can be associated with any number of Contents. The Consumer controls which Contents of a Category are in which state.</p>
<p><b>Assigned</b><br />
 When a Consumer decides to claim an offered Content for himself, the Content state switches to Assigned. The Content is now bound to the Consumer, and no other Consumer can claim it until the assigned Consumer releases this Content again. There are no requirements about the actual graphical content being available on the Consumer side connected to this state.</p>
<p><b>Ready</b><br />
 If a Content is in a Ready state, it means it is not shown, but it could be shown with minimal latency. This implicates that the graphical content is available on the consumer side. Getting to the Ready state from the Assigned state may therefore take some time and may fail, depending on how the graphical content is being made available.</p>
<p><b>Shown</b><br />
 The Content is currently shown. For the Provider this may mean, that it needs to keep the Contents graphical content updated.</p>
<p><b>AcceptStopOffer</b><br />
 This not a real state, but it is used in a ContentStateChange message to allow a Provider to stop offering a Content currently in use by a Consumer.</p>
<h1>Protocol messages</h1>
<p><b>OfferContent(<em>ContentID, Category, ProviderID</em>)</b><br />
 This message is broadcasted by a provider to all connected Consumers. It announces a new Content being Offered by that Provider. It carries a <em>ContentID</em>, which serves as a simple Content identifier and a <em>Category</em>, which defines in which context this Content can be used. The <em>ProviderID</em> identifies the Provider to an interested Consumer.</p>
<p><b>ContentStateChange(<em>ContentID, DcsmState, AnimationInformation, SizeInfo</em>)</b><br />
 This message is sent from Consumer to Provider to either inform about state changes or, in case of switching from Assigned to Ready, request a state change. This request has to be answered with a ContentReady message. Next to the Content identifier <em>ContentID</em> the message contains the new state <em>DcsmState</em> and <em>AnimationInformation</em>.</p>
<p><em>AnimationInformation</em> consists of two time stamps which tell when a synchronized transition between the current and the target state occurs. The first time stamp is the start of the transition animation, the second time stamp is the end of the animation. The time stamps need to be valid for both Consumer and Provider to work properly. It is up to the application to make sure of this. Both time stamps may be 0 for when there is no transition needed or unnecessary, transition makes only sense when switching to or from Shown state. Note that the start time should be chosen in a way that takes latencies (e.g. from network) into account, so that Provider and Consumer start animation and showing event at the same time.</p>
<p>When switching to Shown, the Consumer starts displaying the content at the start time point, Provider animates a transition between start and end time. When switching away from Shown, Consumer stops showing the Content a the end time point, Provider animates a transition between start and end time.</p>
<p>When the state change indicates a Consumer trying to claim Content (state change from Offered to Assigned), and only then, the message has to carry a non-zero <em>SizeInfo</em>, which provides initial size information to the Provider, which now may adapt the graphical content to that size.</p>
<p><b>CanvasSizeChange(<em>ContentID, SizeInfo, AnimationInformation</em>)</b><br />
 This message is sent from the Consumer to the Provider, when the size of the content should change. It has a <em>ContentID</em> and a <em>SizeInfo</em>. It contains the new size as viewport width and height. Additionally, it has <em>AnimationInformation</em>, which carries information for the Provider about when to animate the size change.</p>
<p><b>ContentDescription(<em>ContentID, TechnicalContentType, TechnicalContentDescriptor</em>)</b><br />
 This message carries the <em>ContentID</em> and information about how to be able to receive the actual graphical content. <em>TechnicalContentType</em> is an application defined value which imforms about what kind of mechanism is used to distribute or stream the graphical content, in case there are multiple mechanism available. <em>TechnicalContentDescriptor</em> can be used by the application to communicate about which identifier, address or descriptor shall be used to receive the graphical content. This message is sent from Provider to Consumer, after Consumer is assigned to the Content and before the ContentReady message.</p>
<p>The same TechnicalContentDescriptor might be used for different Contents, if they are within the same Category. This would mean that there are multiple logical contexts which this technical content can offer. A switch from one Content with a TechnicalContentDescriptor to another one with the same descriptor would make the Provider trigger a change of the graphical content from one logical context to another, the Provider may animate a transition between the two contexts according to the AnimationInformation provided.</p>
<p><b>ContentReady(&lt;i&gt;ContentID)</b><br />
 This message is a direct reply of the Provider to to a ContentStateChange message from the Consumer which switches from Assigned to Ready state. When this message is being sent, the Provider has to have the graphical content fully available for use by the Consumer.</p>
<p><b>ContentFocusRequest(<em>ContentID</em>)</b><br />
 The Provider sends this message to the Consumer, if it wants to request the Consumer to switch to the Content <em>ContentID</em> as active Content for that Category. The Consumer may follow that request by bringing the Content to a Shown state or may not follow it by ignoring it.</p>
<p><b>StopOfferContentRequest(<em>ContentID</em>)</b><br />
 The Provider broadcasts this message to all Consumers, if it wants to stop providing the Content <em>ContentID</em>. A Consumer not currently assigned to the Content may now forget about this Content. The assigned Consumer has to reply with a ContentStateChange message for that <em>ContentID</em> and the state AcceptStopOffer. This gives it the opportunity to provide a <em>AnimationInformation</em> in case the Content is in state Shown and needs to be hidden with an animation (see above).</p>
<p>After this ContentStateChange message has been received and the transition animation has been executed and the Content is hidden, the Provider and previously assigned Consumer may release the Content and graphical content.</p>
<p><b>UpdateContentMetadata(<em>ContentID, Metadata</em>)</b><br />
 This message carries arbitrary <em>Metadata</em> related to the Content from the Provider to the assigned Consumer. This message can be sent multiple times, as often as the <em>Metadata</em> needs to be updated, but only after sending the ContentDescription.</p>
<p>DCSM does not define a <em>Metadata</em> format and leaves this for the Consumer and Provider to agree upon by other means. It just carries the <em>Metadata</em> as data blob.</p>
<h1>Implementation</h1>
<p>In the Ramses solution there is a DCSM Implementation. It implements the DCSM protocol specifically to control Ramses scenes.</p>
<p>There are four major components in this implementation:</p>
<ul>
<li>The internal DcsmComponent uses Ramses' ConnectionSystems to communicate to other DCSMComponents and implements all the message and state logic of DCSM in a generic way.</li>
<li>The DcsmProvider is a simplified API which can be used by a content provider application to provide Ramses scenes as content.</li>
<li>The DcsmConsumer is an API which can be used by a consumer application to receive Ramses scenes as Content and render it.</li>
<li>The DcsmContentControl is an API which combines DcsmConsumer control and content rendering state control. It is based on DcsmConsumer and RendererSceneControl and is used to render DCSM content in form of Ramses scenes.</li>
</ul>
<p>Refer to the API documentation for details about usage of the last three API classes.</p>
<h1>Protocol example sequence diagrams</h1>
<ul>
<li>Sequence 1 - Switching between different widgets within one area</li>
</ul>
<div class="image">
<img src="sequence1a.png" alt="sequence1a.png"/>
<div class="caption">
Switching between different widgets within one area - Part I</div></div>
<div class="image">
<img src="sequence1b.png" alt="sequence1b.png"/>
<div class="caption">
Switching between different widgets within one area - Part II</div></div>
<ul>
<li>Sequence 2 - Provider offers event notification, Consumer always shows if possible</li>
</ul>
<div class="image">
<img src="sequence2.png" alt="sequence2.png"/>
<div class="caption">
Provider offers event notification, Consumer always shows if possible</div></div>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
