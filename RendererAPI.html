<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAMSES Documentation: RAMSES Renderer API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ramses_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RAMSES Documentation
   &#160;<span id="projectnumber">25.0.6</span>
   </div>
   <div id="projectbrief">Information for RAMSES users and developers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">RAMSES Renderer API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The RAMSES Renderer API allows to</p><ul>
<li>create displays and offscreen buffers</li>
<li>control rendering states of scenes</li>
<li>link data between scenes</li>
<li>control render looping, timing, limits</li>
<li>access/control to the system compositor controller</li>
</ul>
<h1>Display Management</h1>
<p>The renderer setup consists of a <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">ramses::RamsesRenderer</a> object and a set of displays belonging to it. Every display can be configured through an individual <a class="el" href="classramses_1_1DisplayConfig.html" title="The DisplayConfig holds a set of parameters to be used to initialize a display. ">ramses::DisplayConfig</a>.</p>
<h1>Scene Rendering States</h1>
<p>Graphical content (a <a class="el" href="classramses_1_1Scene.html" title="The Scene holds a scene graph. It is the essential class for distributing content to the ramses syste...">ramses::Scene</a> provided from <a class="el" href="classramses_1_1RamsesClient.html" title="Entry point of RAMSES client API. ">ramses::RamsesClient</a>) is always in a certain state, a state in the context of single <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">ramses::RamsesRenderer</a> instance. Typically the desired state to reach is that the scene is rendered, however the scene has to go through several other states to reach that:</p><ol type="1">
<li>scene is published, i.e. client announced that the scene can be requested from one or more renderers</li>
<li>renderer requests scene and its data, any change to scene data will be transferred to renderer</li>
<li>renderer maps scene to a display, assigns to framebuffer or offscreen buffer and uploads all scene resources</li>
<li>renderer starts to render scene</li>
</ol>
<p>These states and other parameters can be set/requested using <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">ramses::RendererSceneControl</a>, see its documentation for more details.</p>
<div class="image">
<img src="renderer_scene_states.png" alt="renderer_scene_states.png"/>
<div class="caption">
Renderer Scene States: These are internal states that aren't exposed to the high level, but can be found on renderer log output.</div></div>
<h2>Data Linking</h2>
<p>In order to achieve scene interaction, it is possible to attach scene content of one scene to scene content of another scene. There are several types of data links, all of them have a data provider on one side and one or more consumers on the other side, the consumers then use the data of the provider.</p>
<p>Provider and consumer data is tagged with an ID on RAMSES client scene side and then can be linked on RAMSES renderer side. Scenes with provider and consumer data can come from different clients that do not have to know each other (only the tagged data IDs are globally known) and once the scenes are subscribed (mapped in case of texture linking) on renderer they can be linked together.</p>
<p>Data links are dynamic so any change to provider data (including animations) will be reflected to all its consumers.</p>
<h3>Transformation Linking</h3>
<p>For transformation data linking the provided scene content is the transformation matrix of a scenegraph node (any <a class="el" href="classramses_1_1Node.html" title="The Node is the base class of all nodes and provides scene graph functionality which propagates to it...">ramses::Node</a> typed object in scene), which can be consumed by node(s) of consumer scene(s). The consumer node (and all its children in scenegraph topology) will transform using the provider node's transformation.</p>
<h3>DataObject Linking</h3>
<p><a class="el" href="classramses_1_1DataObject.html" title="The DataObject is a base class for data container for storing data in a scene. ">ramses::DataObject</a> can be used to set values of <a class="el" href="classramses_1_1Appearance.html" title="The Appearance describes how an object should look like. ">ramses::Appearance</a> uniforms or <a class="el" href="classramses_1_1LocalCamera.html" title="The LocalCamera base class is part of a scene and defines a view into the scene defined by the client...">ramses::LocalCamera</a> parameters which can also be linked across scenes. As long as data type is matched a data value stored in a <a class="el" href="classramses_1_1DataObject.html" title="The DataObject is a base class for data container for storing data in a scene. ">ramses::DataObject</a> of one scene can be used as uniform input of an <a class="el" href="classramses_1_1Appearance.html" title="The Appearance describes how an object should look like. ">ramses::Appearance</a> in another scene.</p>
<h3>Texture Linking</h3>
<p>Texture resources can be tagged as data providers and can be consumed in another scene by <a class="el" href="classramses_1_1TextureSampler.html" title="The TextureSampler holds a texture and its sampling parameters. ">ramses::TextureSampler</a>. In order to be able to successfully link textures both the provider and consumer scenes have to be mapped to the same display as they are going to share a GPU resource.</p>
<h1>Renderer API calls &amp; Events</h1>
<p>Renderer API calls are handled asynchronously. This means that the result or information about success of the requested renderer operation is not available immediately after the API call. The result of the API call will be delivered via renderer events. The <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">ramses::RamsesRenderer</a> and <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">ramses::RendererSceneControl</a> each offer its own event dispatching mechanism, such that an object implementing <a class="el" href="classramses_1_1IRendererEventHandler.html" title="Provides an interface for handling the result of renderer events. Implementation of this interface mu...">ramses::IRendererEventHandler</a>/<a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html" title="Provides an interface for handling the result of renderer scene control events. Implementation of thi...">ramses::IRendererSceneControlEventHandler</a> interface can handle and process renderer/scene control events.</p>
<p>Events generated as a result of a <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">ramses::RamsesRenderer</a> or <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">ramses::RendererSceneControl</a> API call can have different statuses reported:</p><ul>
<li>[OK] the Renderer API call was successful</li>
<li>[FAIL] the Renderer API call was unsuccessful, check logs for error message</li>
<li>[INDIRECT] the event was generated as consequence of another event from Ramses client side (e.g. scene unpublish or disconnect) or some other internal event</li>
<li>A special case of status report is 'no status' - scene state change requests (<a class="el" href="classramses_1_1RendererSceneControl.html#a3a67e00fdc6770676e44f1bc254604a0" title="Request state change of a scene. ">ramses::RendererSceneControl::setSceneState</a>) might not generate any event in case that a condition to reach desired state is not met (e.g. scene not published, display not created, etc.). Note that these will not timeout explicitly, it is responsibility of the application to implement timeout logic.</li>
</ul>
<h2>Renderer API transactions</h2>
<p>The <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">ramses::RamsesRenderer</a> and <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">ramses::RendererSceneControl</a> calls are queued and only executed when committed. To commit a batch of calls use <a class="el" href="classramses_1_1RamsesRenderer.html#a6307f22a698040fc1f68f771a39ff253" title="Submits renderer commands (API calls on this instance of RamsesRenderer) since previous flush to be e...">ramses::RamsesRenderer::flush()</a> and <a class="el" href="classramses_1_1RendererSceneControl.html#afae8c8a433e1a29ea4912d1db4be7311" title="Submits scene control commands (API calls on RendererSceneControl) since previous flush to be execute...">ramses::RendererSceneControl::flush()</a> respectively. All calls since the last flush will then be executed together (preserving order) in the very next renderer update loop (either <a class="el" href="classramses_1_1RamsesRenderer.html#a8bceaf9ed2fd659a05d2b12645a6bfdd" title="Prepare content to be rendered in next frame and render next frame. This function can not be used in ...">ramses::RamsesRenderer::doOneLoop()</a> or in render thread). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
