<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAMSES Documentation: ramses::IRendererSceneControlEventHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ramses_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RAMSES Documentation
   &#160;<span id="projectnumber">25.0.6</span>
   </div>
   <div id="projectbrief">Information for RAMSES users and developers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceramses.html">ramses</a></li><li class="navelem"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html">IRendererSceneControlEventHandler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classramses_1_1IRendererSceneControlEventHandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ramses::IRendererSceneControlEventHandler Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides an interface for handling the result of renderer scene control events. Implementation of this interface must be passed to <a class="el" href="classramses_1_1RendererSceneControl.html#a78bb4710634109f444c018149b54dd92" title="RendererSceneControl methods push commands to an internal queue which is submitted when calling flush...">ramses::RendererSceneControl::dispatchEvents</a> which will in return invoke methods of the interface according to events that occurred since last dispatching.  
 <a href="classramses_1_1IRendererSceneControlEventHandler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IRendererSceneControlEventHandler_8h_source.html">IRendererSceneControlEventHandler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ramses::IRendererSceneControlEventHandler:</div>
<div class="dyncontent">
<div class="center"><img src="classramses_1_1IRendererSceneControlEventHandler__inherit__graph.png" border="0" usemap="#ramses_1_1IRendererSceneControlEventHandler_inherit__map" alt="Inheritance graph"/></div>
<map name="ramses_1_1IRendererSceneControlEventHandler_inherit__map" id="ramses_1_1IRendererSceneControlEventHandler_inherit__map">
<area shape="rect" id="node2" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html" title="Convenience empty implementation of IRendererSceneControlEventHandler that can be used to derive from..." alt="" coords="7,95,213,136"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4dd3354bd51d0fe332e8f28508e4afaa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a4dd3354bd51d0fe332e8f28508e4afaa">scenePublished</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId)=0</td></tr>
<tr class="memdesc:a4dd3354bd51d0fe332e8f28508e4afaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called if a previously unknown or unpublished scene becomes published.  <a href="#a4dd3354bd51d0fe332e8f28508e4afaa">More...</a><br /></td></tr>
<tr class="separator:a4dd3354bd51d0fe332e8f28508e4afaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d004040870b94940f0a67b843672f83"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a6d004040870b94940f0a67b843672f83">sceneStateChanged</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, <a class="el" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82c">RendererSceneState</a> state)=0</td></tr>
<tr class="memdesc:a6d004040870b94940f0a67b843672f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called when state of a scene changes.  <a href="#a6d004040870b94940f0a67b843672f83">More...</a><br /></td></tr>
<tr class="separator:a6d004040870b94940f0a67b843672f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac016d8f7c0e6ab084f6a8c86481b9288"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#ac016d8f7c0e6ab084f6a8c86481b9288">offscreenBufferLinked</a> (<a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> offscreenBufferId, <a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> consumerScene, <a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a> consumerId, bool success)=0</td></tr>
<tr class="memdesc:ac016d8f7c0e6ab084f6a8c86481b9288"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called when the data link between offscreen buffer and scene's data slot is established.  <a href="#ac016d8f7c0e6ab084f6a8c86481b9288">More...</a><br /></td></tr>
<tr class="separator:ac016d8f7c0e6ab084f6a8c86481b9288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4decbb725ad779954dbcdad427fd6206"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a4decbb725ad779954dbcdad427fd6206">dataLinked</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> providerScene, <a class="el" href="namespaceramses.html#ab41878ab3cb9b206b58f32437faddd7f">dataProviderId_t</a> providerId, <a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> consumerScene, <a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a> consumerId, bool success)=0</td></tr>
<tr class="memdesc:a4decbb725ad779954dbcdad427fd6206"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called when the data link between a data provider and data consumer is established.  <a href="#a4decbb725ad779954dbcdad427fd6206">More...</a><br /></td></tr>
<tr class="separator:a4decbb725ad779954dbcdad427fd6206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4c204c021ddeee45297b7e63275e1b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#afe4c204c021ddeee45297b7e63275e1b">dataUnlinked</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> consumerScene, <a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a> consumerId, bool success)=0</td></tr>
<tr class="memdesc:afe4c204c021ddeee45297b7e63275e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called when the data link between a data provider and data consumer is destroyed.  <a href="#afe4c204c021ddeee45297b7e63275e1b">More...</a><br /></td></tr>
<tr class="separator:afe4c204c021ddeee45297b7e63275e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4144b74fa03903c25022262f2c1c692"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#aa4144b74fa03903c25022262f2c1c692">dataProviderCreated</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, <a class="el" href="namespaceramses.html#ab41878ab3cb9b206b58f32437faddd7f">dataProviderId_t</a> dataProviderId)=0</td></tr>
<tr class="memdesc:aa4144b74fa03903c25022262f2c1c692"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called whenever a data provider is created.  <a href="#aa4144b74fa03903c25022262f2c1c692">More...</a><br /></td></tr>
<tr class="separator:aa4144b74fa03903c25022262f2c1c692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9ea677b8a0f1126fc547d20f273ba5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a7d9ea677b8a0f1126fc547d20f273ba5">dataProviderDestroyed</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, <a class="el" href="namespaceramses.html#ab41878ab3cb9b206b58f32437faddd7f">dataProviderId_t</a> dataProviderId)=0</td></tr>
<tr class="memdesc:a7d9ea677b8a0f1126fc547d20f273ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called when a data provider is destroyed.  <a href="#a7d9ea677b8a0f1126fc547d20f273ba5">More...</a><br /></td></tr>
<tr class="separator:a7d9ea677b8a0f1126fc547d20f273ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa729fd4d30eb716b0dc6a0d1a19cc168"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#aa729fd4d30eb716b0dc6a0d1a19cc168">dataConsumerCreated</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, <a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a> dataConsumerId)=0</td></tr>
<tr class="memdesc:aa729fd4d30eb716b0dc6a0d1a19cc168"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called whenever a data consumer is created.  <a href="#aa729fd4d30eb716b0dc6a0d1a19cc168">More...</a><br /></td></tr>
<tr class="separator:aa729fd4d30eb716b0dc6a0d1a19cc168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6ee43f8171121da99a3d79573aca95"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#abc6ee43f8171121da99a3d79573aca95">dataConsumerDestroyed</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, <a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a> dataConsumerId)=0</td></tr>
<tr class="memdesc:abc6ee43f8171121da99a3d79573aca95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called when a data consumer is destroyed.  <a href="#abc6ee43f8171121da99a3d79573aca95">More...</a><br /></td></tr>
<tr class="separator:abc6ee43f8171121da99a3d79573aca95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205d47bc91ef9d2cc60f39766bdf2bf8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a205d47bc91ef9d2cc60f39766bdf2bf8">sceneFlushed</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, <a class="el" href="namespaceramses.html#ab7aa6bed4d47d2bd0967fc1a5ed6e95b">sceneVersionTag_t</a> sceneVersionTag)=0</td></tr>
<tr class="memdesc:a205d47bc91ef9d2cc60f39766bdf2bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called after a flush with version tag (<a class="el" href="classramses_1_1Scene.html#ac12e7548df54a23bc10c1e5629c1aa88" title="Commits all changes done to the scene since the last flush or since scene creation. This makes a new valid scene state available to all local and remote renderers. ">ramses::Scene::flush</a>) has been applied.  <a href="#a205d47bc91ef9d2cc60f39766bdf2bf8">More...</a><br /></td></tr>
<tr class="separator:a205d47bc91ef9d2cc60f39766bdf2bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994131648d8494923fd77c31a106c4c0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a994131648d8494923fd77c31a106c4c0">sceneExpired</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId)=0</td></tr>
<tr class="memdesc:a994131648d8494923fd77c31a106c4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called if a scene which has an expiration timestamp set (<a class="el" href="classramses_1_1Scene.html#a5a4e0fd8b04ce23881f3089bfc4c9556" title="Expiration timestamp is a point in time till which the scene is considered to be up-to-date. Logic on renderer side will check the time every frame and in case it detects the scene to be rendered after its expiration timestamp it will generate an event (invoke IRendererEventHandler::sceneExpired). ">ramses::Scene::setExpirationTimestamp</a>) is on renderer (not necessarily rendered) at a state that expired, i.e. current time is after the expiration timestamp. This callback is called only once when the scene expires even if scene stays expired in subsequent frames. When the scene is updated again with a new not anymore expired timestamp, <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a24f748b279d85ac3e0d0dc11740614a3" title="This method will be called if a scene which previously expired (ramses::Scene::setExpirationTimestamp...">sceneRecoveredFromExpiration</a> is called.  <a href="#a994131648d8494923fd77c31a106c4c0">More...</a><br /></td></tr>
<tr class="separator:a994131648d8494923fd77c31a106c4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f748b279d85ac3e0d0dc11740614a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a24f748b279d85ac3e0d0dc11740614a3">sceneRecoveredFromExpiration</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId)=0</td></tr>
<tr class="memdesc:a24f748b279d85ac3e0d0dc11740614a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called if a scene which previously expired (<a class="el" href="classramses_1_1Scene.html#a5a4e0fd8b04ce23881f3089bfc4c9556" title="Expiration timestamp is a point in time till which the scene is considered to be up-to-date. Logic on renderer side will check the time every frame and in case it detects the scene to be rendered after its expiration timestamp it will generate an event (invoke IRendererEventHandler::sceneExpired). ">ramses::Scene::setExpirationTimestamp</a> and <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a994131648d8494923fd77c31a106c4c0" title="This method will be called if a scene which has an expiration timestamp set (ramses::Scene::setExpira...">sceneExpired</a>) was updated with a new expiration timestamp that is not expired anymore. This callback is called only once when the scene switches state from expired to not expired.  <a href="#a24f748b279d85ac3e0d0dc11740614a3">More...</a><br /></td></tr>
<tr class="separator:a24f748b279d85ac3e0d0dc11740614a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a3b038e5431ed1a1fdc8f0f4bbf7d9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#ab7a3b038e5431ed1a1fdc8f0f4bbf7d9">streamAvailabilityChanged</a> (<a class="el" href="namespaceramses.html#ac6d2218ebfe794dbe8d0f780f059de83">streamSource_t</a> streamId, bool available)=0</td></tr>
<tr class="memdesc:ab7a3b038e5431ed1a1fdc8f0f4bbf7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called when a new IVI video stream becomes available, or when an existing stream disappears In terms of Wayland protocol, a stream is available if an "ivi_application" exists which has created a wayland surface (wl_surface) with ivi_id=streamId, and the surface has at least one attached non-nullptr buffer (i.e. renderable content).  <a href="#ab7a3b038e5431ed1a1fdc8f0f4bbf7d9">More...</a><br /></td></tr>
<tr class="separator:ab7a3b038e5431ed1a1fdc8f0f4bbf7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce04232c965e1f37fc0d366e69b7c8a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#acce04232c965e1f37fc0d366e69b7c8a">objectsPicked</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, const <a class="el" href="namespaceramses.html#a297993fd73b812e878accd5788e1b82c">pickableObjectId_t</a> *pickedObjects, uint32_t pickedObjectsCount)=0</td></tr>
<tr class="memdesc:acce04232c965e1f37fc0d366e69b7c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called when there were scene objects picked. A <a class="el" href="classramses_1_1PickableObject.html" title="PickableObject provides a way to specify a &#39;pickable&#39; area. ">ramses::PickableObject</a> can be 'picked' via a pick input event which is passed to <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">ramses::RendererSceneControl</a> when the scene is rendered (see <a class="el" href="classramses_1_1RendererSceneControl.html#a6420e4d8b2754d6ac8831a3bda9233bb" title="Trigger renderer to test if given pick event with coordinates intersects with any instances of ramses...">ramses::RendererSceneControl::handlePickEvent</a>).  <a href="#acce04232c965e1f37fc0d366e69b7c8a">More...</a><br /></td></tr>
<tr class="separator:acce04232c965e1f37fc0d366e69b7c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd8d4b47c9ee08733b2f184b4f591e4"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a0dd8d4b47c9ee08733b2f184b4f591e4">~IRendererSceneControlEventHandler</a> ()=default</td></tr>
<tr class="memdesc:a0dd8d4b47c9ee08733b2f184b4f591e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty destructor.  <a href="#a0dd8d4b47c9ee08733b2f184b4f591e4">More...</a><br /></td></tr>
<tr class="separator:a0dd8d4b47c9ee08733b2f184b4f591e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides an interface for handling the result of renderer scene control events. Implementation of this interface must be passed to <a class="el" href="classramses_1_1RendererSceneControl.html#a78bb4710634109f444c018149b54dd92" title="RendererSceneControl methods push commands to an internal queue which is submitted when calling flush...">ramses::RendererSceneControl::dispatchEvents</a> which will in return invoke methods of the interface according to events that occurred since last dispatching. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0dd8d4b47c9ee08733b2f184b4f591e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd8d4b47c9ee08733b2f184b4f591e4">&#9670;&nbsp;</a></span>~IRendererSceneControlEventHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ramses::IRendererSceneControlEventHandler::~IRendererSceneControlEventHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa729fd4d30eb716b0dc6a0d1a19cc168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa729fd4d30eb716b0dc6a0d1a19cc168">&#9670;&nbsp;</a></span>dataConsumerCreated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::IRendererSceneControlEventHandler::dataConsumerCreated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a>&#160;</td>
          <td class="paramname"><em>dataConsumerId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called whenever a data consumer is created. </p>
<p>The event is emitted also for every data consumer in a newly available scene. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The scene id of the scene on which the event occurred </td></tr>
    <tr><td class="paramname">dataConsumerId</td><td>The created data consumer id </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a6db396b314db92c14266deee57164b31">ramses::RendererSceneControlEventHandlerEmpty</a>.</p>

</div>
</div>
<a id="abc6ee43f8171121da99a3d79573aca95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6ee43f8171121da99a3d79573aca95">&#9670;&nbsp;</a></span>dataConsumerDestroyed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::IRendererSceneControlEventHandler::dataConsumerDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a>&#160;</td>
          <td class="paramname"><em>dataConsumerId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called when a data consumer is destroyed. </p>
<p>The event is emitted only when data consumer destroyed, not if scene becomes unavailable as a whole. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The scene id of the scene on which the event occurred </td></tr>
    <tr><td class="paramname">dataConsumerId</td><td>The destroyed data consumer id </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#abe9704414b9cfa42ba1be50f76aaaa19">ramses::RendererSceneControlEventHandlerEmpty</a>.</p>

</div>
</div>
<a id="a4decbb725ad779954dbcdad427fd6206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4decbb725ad779954dbcdad427fd6206">&#9670;&nbsp;</a></span>dataLinked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::IRendererSceneControlEventHandler::dataLinked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>providerScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab41878ab3cb9b206b58f32437faddd7f">dataProviderId_t</a>&#160;</td>
          <td class="paramname"><em>providerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>consumerScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a>&#160;</td>
          <td class="paramname"><em>consumerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called when the data link between a data provider and data consumer is established. </p>
<p>This is a result of <a class="el" href="classramses_1_1RendererSceneControl.html#af4a77700e389a32581ad1b274552b010" title="Links a data provider from one scene to a data consumer in another scene. ">ramses::RendererSceneControl::linkData</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">providerScene</td><td>The ID of scene where the data provider slot is </td></tr>
    <tr><td class="paramname">providerId</td><td>The ID of data provider which was linked </td></tr>
    <tr><td class="paramname">consumerScene</td><td>The ID of scene where the data consumer slot is </td></tr>
    <tr><td class="paramname">consumerId</td><td>The ID of data consumer which was linked </td></tr>
    <tr><td class="paramname">success</td><td>True if succeeded, false otherwise - check renderer logs for concrete error message. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a55b651548efc36f59d0276d673f3c38c">ramses::RendererSceneControlEventHandlerEmpty</a>.</p>

</div>
</div>
<a id="aa4144b74fa03903c25022262f2c1c692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4144b74fa03903c25022262f2c1c692">&#9670;&nbsp;</a></span>dataProviderCreated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::IRendererSceneControlEventHandler::dataProviderCreated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab41878ab3cb9b206b58f32437faddd7f">dataProviderId_t</a>&#160;</td>
          <td class="paramname"><em>dataProviderId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called whenever a data provider is created. </p>
<p>The event is emitted also for every data provider in a newly available scene. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The scene id of the scene on which the event occurred </td></tr>
    <tr><td class="paramname">dataProviderId</td><td>The created data provider id </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a81a9ba13148c9511965bc1df17d2574f">ramses::RendererSceneControlEventHandlerEmpty</a>.</p>

</div>
</div>
<a id="a7d9ea677b8a0f1126fc547d20f273ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9ea677b8a0f1126fc547d20f273ba5">&#9670;&nbsp;</a></span>dataProviderDestroyed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::IRendererSceneControlEventHandler::dataProviderDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab41878ab3cb9b206b58f32437faddd7f">dataProviderId_t</a>&#160;</td>
          <td class="paramname"><em>dataProviderId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called when a data provider is destroyed. </p>
<p>The event is emitted only when data provider destroyed, not if scene becomes unavailable as a whole. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The scene id of the scene on which the event occurred </td></tr>
    <tr><td class="paramname">dataProviderId</td><td>The destroyed data provider id </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#ace4eb3e937770dfe41c8726e25da5545">ramses::RendererSceneControlEventHandlerEmpty</a>.</p>

</div>
</div>
<a id="afe4c204c021ddeee45297b7e63275e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4c204c021ddeee45297b7e63275e1b">&#9670;&nbsp;</a></span>dataUnlinked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::IRendererSceneControlEventHandler::dataUnlinked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>consumerScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a>&#160;</td>
          <td class="paramname"><em>consumerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called when the data link between a data provider and data consumer is destroyed. </p>
<p>This is a result of <a class="el" href="classramses_1_1RendererSceneControl.html#a3705492a690fa9ec03ce9f5a50e74994" title="Removes an existing link between data provider and consumer (linkData) or offscreen buffer and consum...">ramses::RendererSceneControl::unlinkData</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">consumerScene</td><td>The ID of scene where the data consumer slot is </td></tr>
    <tr><td class="paramname">consumerId</td><td>The ID of data consumer which was unlinked </td></tr>
    <tr><td class="paramname">success</td><td>True if succeeded, false otherwise - check renderer logs for concrete error message. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a2b50349138c5a3a21b34230cbc1906a2">ramses::RendererSceneControlEventHandlerEmpty</a>.</p>

</div>
</div>
<a id="acce04232c965e1f37fc0d366e69b7c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce04232c965e1f37fc0d366e69b7c8a">&#9670;&nbsp;</a></span>objectsPicked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::IRendererSceneControlEventHandler::objectsPicked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceramses.html#a297993fd73b812e878accd5788e1b82c">pickableObjectId_t</a> *&#160;</td>
          <td class="paramname"><em>pickedObjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pickedObjectsCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called when there were scene objects picked. A <a class="el" href="classramses_1_1PickableObject.html" title="PickableObject provides a way to specify a &#39;pickable&#39; area. ">ramses::PickableObject</a> can be 'picked' via a pick input event which is passed to <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">ramses::RendererSceneControl</a> when the scene is rendered (see <a class="el" href="classramses_1_1RendererSceneControl.html#a6420e4d8b2754d6ac8831a3bda9233bb" title="Trigger renderer to test if given pick event with coordinates intersects with any instances of ramses...">ramses::RendererSceneControl::handlePickEvent</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sceneId</td><td>ID of scene to which the picked objects belong. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pickedObjects</td><td>Pointer to first ID of the picked objects array. This array is valid only for the time of calling this method. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pickedObjectsCount</td><td>Number of picked object IDs in the <code>pickedObjects</code> array. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a6cdd89c1076420d99a0684ab306e7e73">ramses::RendererSceneControlEventHandlerEmpty</a>.</p>

</div>
</div>
<a id="ac016d8f7c0e6ab084f6a8c86481b9288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac016d8f7c0e6ab084f6a8c86481b9288">&#9670;&nbsp;</a></span>offscreenBufferLinked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::IRendererSceneControlEventHandler::offscreenBufferLinked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td>
          <td class="paramname"><em>offscreenBufferId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>consumerScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a>&#160;</td>
          <td class="paramname"><em>consumerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called when the data link between offscreen buffer and scene's data slot is established. </p>
<p>This is a result of <a class="el" href="classramses_1_1RendererSceneControl.html#a404275629b0b73ad04d10f4a1649e8ba" title="Links display&#39;s offscreen buffer to a data consumer in scene. ">ramses::RendererSceneControl::linkOffscreenBuffer</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offscreenBufferId</td><td>The ID of offscreen buffer which is linked as data provider </td></tr>
    <tr><td class="paramname">consumerScene</td><td>The ID of scene where the data consumer slot is </td></tr>
    <tr><td class="paramname">consumerId</td><td>The ID of data consumer where the offscreen buffer is linked to </td></tr>
    <tr><td class="paramname">success</td><td>True if succeeded, false otherwise - check renderer logs for concrete error message. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a53ade79e2fea4c8129ac9420e6fa7237">ramses::RendererSceneControlEventHandlerEmpty</a>.</p>

</div>
</div>
<a id="a994131648d8494923fd77c31a106c4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994131648d8494923fd77c31a106c4c0">&#9670;&nbsp;</a></span>sceneExpired()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::IRendererSceneControlEventHandler::sceneExpired </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called if a scene which has an expiration timestamp set (<a class="el" href="classramses_1_1Scene.html#a5a4e0fd8b04ce23881f3089bfc4c9556" title="Expiration timestamp is a point in time till which the scene is considered to be up-to-date. Logic on renderer side will check the time every frame and in case it detects the scene to be rendered after its expiration timestamp it will generate an event (invoke IRendererEventHandler::sceneExpired). ">ramses::Scene::setExpirationTimestamp</a>) is on renderer (not necessarily rendered) at a state that expired, i.e. current time is after the expiration timestamp. This callback is called only once when the scene expires even if scene stays expired in subsequent frames. When the scene is updated again with a new not anymore expired timestamp, <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a24f748b279d85ac3e0d0dc11740614a3" title="This method will be called if a scene which previously expired (ramses::Scene::setExpirationTimestamp...">sceneRecoveredFromExpiration</a> is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The scene id of the scene on which the event occurred </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#abbc3814bfdaaf45fed51abdb3669dfa1">ramses::RendererSceneControlEventHandlerEmpty</a>.</p>

</div>
</div>
<a id="a205d47bc91ef9d2cc60f39766bdf2bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205d47bc91ef9d2cc60f39766bdf2bf8">&#9670;&nbsp;</a></span>sceneFlushed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::IRendererSceneControlEventHandler::sceneFlushed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab7aa6bed4d47d2bd0967fc1a5ed6e95b">sceneVersionTag_t</a>&#160;</td>
          <td class="paramname"><em>sceneVersionTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called after a flush with version tag (<a class="el" href="classramses_1_1Scene.html#ac12e7548df54a23bc10c1e5629c1aa88" title="Commits all changes done to the scene since the last flush or since scene creation. This makes a new valid scene state available to all local and remote renderers. ">ramses::Scene::flush</a>) has been applied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The scene id of the scene which the versioned flush belongs to </td></tr>
    <tr><td class="paramname">sceneVersionTag</td><td>The version tag of the scene flush </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a128450bdd7ef264424ef1f99036b6eb0">ramses::RendererSceneControlEventHandlerEmpty</a>.</p>

</div>
</div>
<a id="a4dd3354bd51d0fe332e8f28508e4afaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd3354bd51d0fe332e8f28508e4afaa">&#9670;&nbsp;</a></span>scenePublished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::IRendererSceneControlEventHandler::scenePublished </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called if a previously unknown or unpublished scene becomes published. </p>
<p>This is just informative callback, a scene can be set to a certain RendererSceneState even if it is not published yet/anymore, see <a class="el" href="classramses_1_1RendererSceneControl.html#a3a67e00fdc6770676e44f1bc254604a0" title="Request state change of a scene. ">ramses::RendererSceneControl::setSceneState</a>. Even though scene's RendererSceneState depends on whether scene is published or not, there is no 1:1 representation of published/unpublished in RendererSceneState enumeration, this comes partially from the fact that publish/unpublish is controlled from <a class="el" href="classramses_1_1RamsesClient.html" title="Entry point of RAMSES client API. ">RamsesClient</a> API, not the renderer's scene control API. There is no explicit callback when scene is unpublished, its state would be reported as <a class="el" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82ca453e6aa38d87b28ccae545967c53004f" title="Scene is unavailable (renderer is not subscribed to scene data), scene can be either unpublished or p...">RendererSceneState::Unavailable</a> via <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a6d004040870b94940f0a67b843672f83" title="This method will be called when state of a scene changes. ">sceneStateChanged</a> as side effect, however a scene being in state <a class="el" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82ca453e6aa38d87b28ccae545967c53004f" title="Scene is unavailable (renderer is not subscribed to scene data), scene can be either unpublished or p...">RendererSceneState::Unavailable</a> does not necessarily mean it is unpublished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The ID of scene that was published </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a07631c10e8e982729b6a870f3925b1af">ramses::RendererSceneControlEventHandlerEmpty</a>.</p>

</div>
</div>
<a id="a24f748b279d85ac3e0d0dc11740614a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f748b279d85ac3e0d0dc11740614a3">&#9670;&nbsp;</a></span>sceneRecoveredFromExpiration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::IRendererSceneControlEventHandler::sceneRecoveredFromExpiration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called if a scene which previously expired (<a class="el" href="classramses_1_1Scene.html#a5a4e0fd8b04ce23881f3089bfc4c9556" title="Expiration timestamp is a point in time till which the scene is considered to be up-to-date. Logic on renderer side will check the time every frame and in case it detects the scene to be rendered after its expiration timestamp it will generate an event (invoke IRendererEventHandler::sceneExpired). ">ramses::Scene::setExpirationTimestamp</a> and <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a994131648d8494923fd77c31a106c4c0" title="This method will be called if a scene which has an expiration timestamp set (ramses::Scene::setExpira...">sceneExpired</a>) was updated with a new expiration timestamp that is not expired anymore. This callback is called only once when the scene switches state from expired to not expired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The scene id of the scene on which the event occurred </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a9fa78efc7b932172dd94a233bad9c4ec">ramses::RendererSceneControlEventHandlerEmpty</a>.</p>

</div>
</div>
<a id="a6d004040870b94940f0a67b843672f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d004040870b94940f0a67b843672f83">&#9670;&nbsp;</a></span>sceneStateChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::IRendererSceneControlEventHandler::sceneStateChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82c">RendererSceneState</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called when state of a scene changes. </p>
<p>Typically this is a result of <a class="el" href="classramses_1_1RendererSceneControl.html#a3a67e00fdc6770676e44f1bc254604a0" title="Request state change of a scene. ">ramses::RendererSceneControl::setSceneState</a> call but can be also triggered externally (e.g. scene was unpublished by client). Note that there can be multiple state change callbacks in a row depending on number of state transitions needed between the previous state and target state when calling <a class="el" href="classramses_1_1RendererSceneControl.html#a3a67e00fdc6770676e44f1bc254604a0" title="Request state change of a scene. ">ramses::RendererSceneControl::setSceneState</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The ID of scene with changed state </td></tr>
    <tr><td class="paramname">state</td><td>New state of the scene </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a89bbf910ecb31b0ec8ee9b4298c426c1">ramses::RendererSceneControlEventHandlerEmpty</a>.</p>

</div>
</div>
<a id="ab7a3b038e5431ed1a1fdc8f0f4bbf7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a3b038e5431ed1a1fdc8f0f4bbf7d9">&#9670;&nbsp;</a></span>streamAvailabilityChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::IRendererSceneControlEventHandler::streamAvailabilityChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ac6d2218ebfe794dbe8d0f780f059de83">streamSource_t</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called when a new IVI video stream becomes available, or when an existing stream disappears In terms of Wayland protocol, a stream is available if an "ivi_application" exists which has created a wayland surface (wl_surface) with ivi_id=streamId, and the surface has at least one attached non-nullptr buffer (i.e. renderable content). </p>
<p>It is possible that the ivi_application does not update its surface (by providing new buffers/frames), but RAMSES has no way of knowing that, hence a stream is not reported unavailable in that case.</p>
<p>A surface becomes unavailable whenever either the ivi_application is closed or when it attached a nullptr buffer to the stream surface with id=streamId (i.e. actively told wayland that it should not render contents to this ivi surface).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td>The IVI stream id </td></tr>
    <tr><td class="paramname">available</td><td>True if the stream became available, and false if it disappeared </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a247ec2a9253f75fa3babfd65e0222212">ramses::RendererSceneControlEventHandlerEmpty</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/q479079/sources/ramses-oss/renderer/RendererLib/ramses-renderer-api/include/ramses-renderer-api/<a class="el" href="IRendererSceneControlEventHandler_8h_source.html">IRendererSceneControlEventHandler.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
